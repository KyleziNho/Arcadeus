<!doctype html>
<html>
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Arcadeus</title>
    <script src="https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Lora:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="taskpane.css">
    <link rel="stylesheet" href="styles/multi-agent-status.css">
    <link rel="stylesheet" href="styles/professional-chat-interface.css">
    <link rel="stylesheet" href="styles/scenario-analysis-engine.css">
    <link rel="stylesheet" href="styles/model-validation-dashboard.css">
    <link rel="stylesheet" href="styles/formatted-chat-responses.css">
    <link rel="stylesheet" href="styles/excel-action-agent.css">
    <link rel="stylesheet" href="styles/langchain-chat.css">
    <!-- Widget Scripts -->
    <script src="widgets/ExcelGenerator.js?v=19"></script>
    <script src="widgets/ExcelActionAgent.js"></script>
    
    <!-- Enhanced Agent System -->
    <script src="widgets/AgentTools.js"></script>
    <script src="widgets/AgentWorkflows.js"></script>
    <script src="widgets/EnhancedExcelAgent.js"></script>
    <script src="widgets/AgentEvaluator.js"></script>
    <script src="widgets/ConversationStateManager.js"></script>
    <script src="widgets/DirectExcelActions.js"></script>
    <script src="widgets/SafeExcelContext.js"></script>
    <script src="widgets/EnhancedResponseFormatter.js"></script>
    <script>
        // Verify ExcelGenerator loaded
        console.log('üîß Checking ExcelGenerator availability...');
        console.log('window.ExcelGenerator:', typeof window.ExcelGenerator);
        console.log('ExcelGenerator:', typeof ExcelGenerator);
        
        if (typeof window.ExcelGenerator === 'undefined') {
            console.error('‚ùå window.ExcelGenerator is undefined');
        } else {
            console.log('‚úÖ window.ExcelGenerator is available');
        }
        
        if (typeof ExcelGenerator === 'undefined') {
            console.error('‚ùå ExcelGenerator global is undefined');
        } else {
            console.log('‚úÖ ExcelGenerator global is available');
        }
    </script>
    <script src="widgets/FormHandler.js"></script>
    <script src="widgets/FileUploader.js"></script>
    <script src="widgets/ExcelLiveAnalyzer.js"></script>
    <script src="widgets/ChatHandler.js"></script>
    <script src="widgets/DataManager.js"></script>
    <script src="widgets/UIController.js"></script>
    
    <!-- Enhanced Chat Formatting -->
    <script src="widgets/excel-navigator.js"></script>
    <script src="widgets/enhanced-formatting-injector.js"></script>
    <script src="widgets/direct-response-formatter.js"></script>
    
    <!-- Phase 1: Native Excel Integration -->
    <script src="widgets/excel-structure-fetcher.js"></script>
    
    <!-- Stage 2: Multi-Agent System -->
    <script src="widgets/multi-agent-processor.js"></script>
    <script src="widgets/enhanced-status-indicators.js"></script>
    
    <!-- Stage 3: Professional Features -->
    <script src="widgets/professional-chat-interface.js"></script>
    <script src="widgets/scenario-analysis-engine.js"></script>
    <script src="widgets/model-validation-dashboard.js"></script>
    
    <!-- Critical Fix: Response Formatting -->
    <!-- Accurate Excel Value Finder - Ensures AI uses real data -->
    <script src="widgets/AccurateExcelValueFinder.js"></script>
    <!-- LangChain Excel Tools - Proper tool calling implementation -->
    <script src="widgets/LangChainExcelTools.js"></script>
    <!-- New: LangChain Proper Tools following expert implementation -->
    <script src="widgets/LangChainProperTools.js"></script>
    <!-- New: LangChain ReAct Agent with step-by-step reasoning -->
    <script src="widgets/LangChainReActAgent.js"></script>
    <!-- UNIFIED AI AGENT SYSTEM -->
    <!-- Comprehensive Excel API Library -->
    <script src="widgets/UnifiedExcelApiLibrary.js"></script>
    <!-- Single Unified AI Agent (OpenAI + Excel) -->
    <script src="widgets/UnifiedAiAgent.js"></script>
    <!-- Hybrid Agent (adds planning for complex workflows) -->
    <script src="widgets/HybridExcelAgent.js"></script>
    <!-- Excel MCP Chat Agent - Complete MCP server implementation -->
    <script src="widgets/ExcelMCPChatAgent.js"></script>
    <!-- Deep Excel Agent (Full Deep Agents implementation) -->
    <script src="widgets/DeepExcelAgent.js"></script>
    <!-- MCP-Style Excel Tool Library (extracted patterns) -->
    <script src="widgets/ExcelToolLibrary.js"></script>
    <!-- Enhanced Deep Agent with MCP Integration -->
    <script src="widgets/DeepAgentExcelIntegration.js"></script>
    <!-- New: LangGraph Excel Integration - Professional workflow management -->
    <script src="widgets/LangGraphWebImplementation.js"></script>
    <!-- LangChain AI System - Complete Replacement -->
    <!-- Note: Using bundled version for Excel Add-in compatibility -->
    <script src="widgets/langchain-excel-integration.js"></script>
    <!-- LangChain Chat Orchestrator - Central handler for all chat I/O -->
    <script src="widgets/LangChainChatOrchestrator.js"></script>
    
    <!-- Legacy AI Extraction -->
    <script src="widgets/MasterDataAnalyzer.js"></script>
    
    <!-- New AI Extraction System - Core Services -->
    <script src="widgets/services/AIExtractionService.js"></script>
    <script src="widgets/core/FileDropZone.js"></script>
    <script src="widgets/core/DataStandardizer.js"></script>
    <script src="widgets/core/FieldMappingEngine.js"></script>
    <script src="widgets/core/ExtractionHistory.js"></script>
    
    <!-- New AI Extraction System - Extraction Widgets -->
    <script src="widgets/extractors/HighLevelParametersExtractor.js"></script>
    <script src="widgets/extractors/DealAssumptionsExtractor.js"></script>
    <script src="widgets/extractors/RevenueItemsExtractor.js"></script>
    <script src="widgets/extractors/CostItemsExtractor.js"></script>
    <script src="widgets/extractors/DebtModelExtractor.js"></script>
    <script src="widgets/extractors/ExitAssumptionsExtractor.js"></script>
    
    <!-- New AI Extraction System - UI Components -->
    <script src="widgets/ui/ExtractionConfidenceIndicator.js"></script>
    <script src="widgets/ui/ExtractionReviewModal.js"></script>
    
    <!-- New AI Extraction System - Integration -->
    <script src="widgets/AutoFillIntegrator.js"></script>
    
    <!-- Firebase SDK and Auth -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="auth.js"></script>
    
    <!-- Main Application Script -->
    <script defer="defer" src="taskpane.js"></script>
</head>
<body>
    <!-- Auth Loading Screen -->
    <div id="authLoading" class="auth-loading-screen">
        <div class="loading-content">
            <img src="assets/arcadeus.svg" alt="Arcadeus" class="loading-logo">
        </div>
    </div>

    <!-- Main App Content (hidden initially) -->
    <div id="mainApp" class="container" style="display: none;">
        <!-- Clean Header -->
        <div class="app-header">
            <div class="brand-container">
                <img src="assets/Arcadeus.svg" alt="Arcadeus" class="header-logo" onclick="showAssumptions()" style="cursor: pointer;">
            </div>
            <div class="nav-tabs">
                <button class="nav-tab active" id="assumptionsTab" onclick="showAssumptions()">Assumptions</button>
                <button class="nav-tab" id="chatTab" onclick="showChat()">Chat</button>
            </div>
            <div class="profile-section">
                <button class="menu-icon" id="menuIcon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <div class="menu-dropdown" id="menuDropdown">
                    <a href="profile.html" class="menu-item">View Profile</a>
                    <button class="menu-item" onclick="autoFillWithAI()">Auto Fill with AI</button>
                    <button class="menu-item" id="signOutButton">Log Out</button>
                </div>
            </div>
        </div>

        <!-- Assumptions Page -->
        <div id="assumptionsPage" class="page-content">
            <!-- Progress Bar -->
            <div class="progress-container">
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="assumptionsProgress">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text">
                        <span id="progressText">0 of 7 sections completed</span>
                    </div>
                </div>
            </div>
            
            <!-- Horizontal Tab Navigation -->
            <div class="assumptions-tabs">
                <button class="assumption-tab active" data-tab="highLevelParameters">Deal Profile</button>
                <button class="assumption-tab" data-tab="dealAssumptions">Deal Assumptions</button>
                <button class="assumption-tab" data-tab="revenueItems">Revenue Items</button>
                <button class="assumption-tab" data-tab="operatingExpenses">Operating Expenses</button>
                <button class="assumption-tab" data-tab="capEx">Capital Expenses</button>
                <button class="assumption-tab" data-tab="exitAssumptions">Exit Assumptions</button>
                <button class="assumption-tab" data-tab="debtModel">Debt Financing</button>
            </div>
            
            <!-- Tab Content Container -->
            <div class="assumptions-content">
                <!-- Deal Profile Tab Panel -->
                <div class="tab-panel active" id="highLevelParameters">
                    <div class="tab-content">
                        <div class="form-group">
                            <label>Currency</label>
                            <select id="currency">
                                <option value="USD">USD - US Dollar</option>
                                <option value="EUR">EUR - Euro</option>
                                <option value="GBP">GBP - British Pound</option>
                                <option value="JPY">JPY - Japanese Yen</option>
                                <option value="CAD">CAD - Canadian Dollar</option>
                                <option value="AUD">AUD - Australian Dollar</option>
                                <option value="CHF">CHF - Swiss Franc</option>
                                <option value="CNY">CNY - Chinese Yuan</option>
                                <option value="SEK">SEK - Swedish Krona</option>
                                <option value="NOK">NOK - Norwegian Krone</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Project Start Date</label>
                            <input type="date" id="projectStartDate" />
                        </div>
                        
                        <div class="form-group">
                            <label>Model Periods</label>
                            <select id="modelPeriods">
                                <option value="daily">Daily</option>
                                <option value="monthly" selected>Monthly</option>
                                <option value="quarterly">Quarterly</option>
                                <option value="yearly">Yearly</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Project End Date</label>
                            <input type="date" id="projectEndDate" />
                        </div>
                        
                        <div class="form-group">
                            <label>Holding Periods (Calculated)</label>
                            <input type="text" id="holdingPeriodsCalculated" readonly placeholder="Select dates and period type to calculate" />
                            <small class="help-text">Automatically calculated based on start/end dates and period type</small>
                        </div>
                    </div>
                </div>

                <!-- Deal Assumptions Tab Panel -->
                <div class="tab-panel" id="dealAssumptions">
                    <div class="tab-content">
                        <div class="form-group">
                            <label>Deal Name</label>
                            <input type="text" id="dealName" placeholder="e.g., TechCo Acquisition"/>
                            <small class="help-text">Name or identifier for this transaction</small>
                        </div>
                        <div class="form-group">
                            <label>Deal Value</label>
                            <input type="number" id="dealValue" placeholder="e.g., 100000000" step="1000000"/>
                            <small class="help-text">Enter the total transaction value in your selected currency</small>
                        </div>
                        <div class="form-group">
                            <label>Transaction Fee (%)</label>
                            <input type="number" id="transactionFee" placeholder="e.g., 2.5" step="0.1"/>
                            <small class="help-text">Investment banking and advisory fees as percentage of deal value</small>
                        </div>
                        <div class="form-group">
                            <label>Deal LTV (%)</label>
                            <input type="number" id="dealLTV" placeholder="e.g., 70" step="1"/>
                            <small class="help-text">Loan-to-Value ratio for debt financing</small>
                        </div>
                        <div class="form-group">
                            <label>Acquisition Equity Contribution (Calculated)</label>
                            <input type="text" id="equityContribution" readonly placeholder="Will calculate based on Deal Value and LTV"/>
                            <small class="help-text">Equity required to acquire the company: Deal Value √ó (100% - LTV%)</small>
                        </div>
                        <div class="form-group">
                            <label>Debt Financing (Calculated)</label>
                            <input type="text" id="debtFinancing" readonly placeholder="Will calculate based on Deal Value and LTV"/>
                            <small class="help-text">Debt portion of acquisition: Deal Value √ó LTV%</small>
                        </div>
                    </div>
                </div>

                <!-- Revenue Items Tab Panel -->
                <div class="tab-panel" id="revenueItems">
                    <div class="tab-content">
                        <div class="revenue-items-container" id="revenueItemsContainer">
                            <div class="revenue-item" id="revenueItem_1">
                                <div class="revenue-item-header">
                                    <span class="revenue-item-title">Revenue Item 1</span>
                                    <button class="remove-revenue-item" onclick="window.formHandler?.removeRevenueItem?.(this.parentElement.parentElement)">Remove</button>
                                </div>
                                
                                <div class="form-group">
                                    <label for="revenueName_1">Revenue Source Name</label>
                                    <input type="text" id="revenueName_1" placeholder="e.g., Product Sales" />
                                </div>
                                
                                <div class="form-group">
                                    <label for="revenueValue_1">Base Value (Year 1)</label>
                                    <input type="number" id="revenueValue_1" placeholder="100000" step="1000" />
                                </div>
                                
                                <div class="form-group">
                                    <label for="revenueGrowthRate_1">Linear Growth Rate (%)</label>
                                    <input type="number" id="revenueGrowthRate_1" placeholder="e.g., 5" step="0.1" />
                                    <small class="help-text">Annual growth rate (e.g., 5 for 5% growth)</small>
                                </div>
                            </div>
                        </div>
                        <div class="revenue-actions">
                            <button class="add-item-button" id="addRevenueItem">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="8" x2="12" y2="16"></line>
                                    <line x1="8" y1="12" x2="16" y2="12"></line>
                                </svg>
                                Add Revenue Item
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Operating Expenses Tab Panel -->
                <div class="tab-panel" id="operatingExpenses">
                    <div class="tab-content">
                        <div class="cost-items-container" id="operatingExpensesContainer">
                            <div class="cost-item" id="opExItem_1">
                                <div class="cost-item-header">
                                    <span class="cost-item-title">Operating Expense 1</span>
                                    <button class="remove-cost-item" onclick="window.formHandler?.removeOperatingExpense?.(this.parentElement.parentElement)">Remove</button>
                                </div>
                                
                                <div class="form-group">
                                    <label for="opExName_1">Expense Name</label>
                                    <input type="text" id="opExName_1" placeholder="e.g., Staff Costs" />
                                </div>
                                
                                <div class="form-group">
                                    <label for="opExValue_1">Annual Value</label>
                                    <input type="number" id="opExValue_1" placeholder="50000" step="1000" />
                                </div>
                                
                                <div class="form-group">
                                    <label for="opExGrowthRate_1">Linear Growth Rate (%)</label>
                                    <input type="number" id="opExGrowthRate_1" placeholder="e.g., 3" step="0.1" />
                                    <small class="help-text">Annual growth rate (e.g., 3 for 3% growth)</small>
                                </div>
                            </div>
                        </div>
                        <div class="cost-actions">
                            <button class="add-item-button" id="addOperatingExpense">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="8" x2="12" y2="16"></line>
                                    <line x1="8" y1="12" x2="16" y2="12"></line>
                                </svg>
                                Add Operating Expense
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Capital Expenses Tab Panel -->
                <div class="tab-panel" id="capEx">
                    <div class="tab-content">
                        <p style="margin-bottom: 15px; color: #666; font-size: 14px;">
                            Ongoing capital expenditures for property improvements, maintenance, and upgrades
                        </p>
                        <div class="cost-items-container" id="capExContainer">
                            <div class="cost-item" id="capExItem_1">
                                <div class="cost-item-header">
                                    <span class="cost-item-title">CapEx 1</span>
                                    <button class="remove-cost-item" onclick="window.formHandler?.removeCapExItem?.(this.parentElement.parentElement)">Remove</button>
                                </div>
                                
                                <div class="form-group">
                                    <label for="capExName_1">CapEx Name</label>
                                    <input type="text" id="capExName_1" placeholder="e.g., Property Improvements" />
                                </div>
                                
                                <div class="form-group">
                                    <label for="capExValue_1">Annual Value</label>
                                    <input type="number" id="capExValue_1" placeholder="50000" step="1000" />
                                </div>
                                
                                <div class="form-group">
                                    <label for="capExGrowthRate_1">Linear Growth Rate (%)</label>
                                    <input type="number" id="capExGrowthRate_1" placeholder="e.g., 3" step="0.1" />
                                    <small class="help-text">Annual growth rate (e.g., 3 for 3% growth)</small>
                                </div>
                            </div>
                        </div>
                        <div class="cost-actions">
                            <button class="add-item-button" id="addCapExItem">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="8" x2="12" y2="16"></line>
                                    <line x1="8" y1="12" x2="16" y2="12"></line>
                                </svg>
                                Add CapEx Item
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Exit Assumptions Tab Panel -->
                <div class="tab-panel" id="exitAssumptions">
                    <div class="tab-content">
                        <div class="form-group">
                            <label>Disposal Cost (%)</label>
                            <input type="number" id="disposalCost" placeholder="e.g., 2.5" step="0.1"/>
                            <small class="help-text">Transaction costs for selling the investment (legal, banking, advisory fees)</small>
                        </div>
                        
                        <div class="form-group">
                            <label>Terminal Cap Rate (%)</label>
                            <input type="number" id="terminalCapRate" placeholder="e.g., 8.5" step="0.1"/>
                            <small class="help-text">Capitalization rate used to determine terminal value at exit</small>
                        </div>
                        
                        <div class="form-group">
                            <label>Discount Rate - WACC (%)</label>
                            <input type="number" id="discountRate" placeholder="e.g., 10.0" step="0.1"/>
                            <small class="help-text">Weighted Average Cost of Capital used for NPV calculations</small>
                        </div>
                    </div>
                </div>

                <!-- Debt Financing Tab Panel -->
                <div class="tab-panel" id="debtModel">
                    <div class="tab-content">
                        <!-- Debt Configuration -->
                        <div class="debt-config-group">
                            <div class="form-group">
                                <label>Debt Financing Status</label>
                                <div class="debt-status" id="debtStatus">
                                    <div class="status-message" id="debtStatusMessage">
                                        Please input a higher LTV to access debt financing options
                                    </div>
                                </div>
                            </div>

                            <div class="debt-settings" id="debtSettings" style="display: none;">
                                <div class="form-group">
                                    <label>Loan Issuance Fees (%)</label>
                                    <input type="number" id="loanIssuanceFees" placeholder="e.g., 1.5" step="0.1">
                                    <small class="help-text">Fees for arranging and issuing the debt financing</small>
                                </div>
                                
                                <div class="form-group">
                                    <label>Interest Rate (%)</label>
                                    <input type="number" id="fixedRate" placeholder="e.g., 5.5" step="0.1">
                                    <small class="help-text">Annual interest rate for the debt financing</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Assumptions Page -->

        <!-- Chat Page -->
        <div id="chatPage" class="page-content enhanced-chat-page" style="display: none;">
            <!-- Enhanced Chat Header - Hidden for minimalist design -->
            <div class="chat-header" style="display: none;">
                <div class="chat-header-left">
                    <h3>AI Assistant</h3>
                    <span id="selectionIndicator" class="selection-indicator">No cell selected</span>
                </div>
                
                <div class="chat-header-right">
                    <!-- Model Selector -->
                    <div class="model-selector-wrapper">
                        <label for="modelSelector">Model:</label>
                        <select id="modelSelector" class="model-selector">
                            <option value="gpt-4" selected>ChatGPT 4</option>
                            <option value="claude-sonnet" disabled>Claude Sonnet 3.5 (Not Configured)</option>
                            <option value="claude-opus" disabled>Claude Opus 3 (Not Configured)</option>
                            <option value="gemini-pro" disabled>Gemini 1.5 Pro (Not Configured)</option>
                        </select>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="header-actions">
                        <button id="undoBtn" class="icon-btn" title="Undo (Ctrl+Z)" disabled>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 7v6h6"/>
                                <path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/>
                            </svg>
                        </button>
                        
                        <button id="redoBtn" class="icon-btn" title="Redo (Ctrl+Y)" disabled>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 7v6h-6"/>
                                <path d="M3 17a9 9 0 019-9 9 9 0 016 2.3L21 13"/>
                            </svg>
                        </button>
                        
                        <button id="clearChatBtn" class="icon-btn" title="Clear Chat">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18"/>
                                <path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                                <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6"/>
                            </svg>
                        </button>
                        
                        <button id="settingsBtn" class="icon-btn" title="Settings">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"/>
                                <path d="M12 1v6m0 6v6m4.22-13.22l4.24 4.24M1.54 9.96l4.24 4.24M7.78 7.78L3.54 3.54M20.46 20.46l-4.24-4.24M16.22 16.22l4.24 4.24M3.54 20.46l4.24-4.24"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Excel Context Bar - Hidden for minimalist design -->
            <div class="excel-context-bar" style="display: none;">
                <div class="context-item">
                    <span class="context-label">üìä Cell:</span>
                    <span id="selectedRange" class="context-value selected-cell">Click on Excel cell...</span>
                </div>
                <div class="context-item">
                    <span class="context-label">Value:</span>
                    <span id="cellValue" class="context-value">-</span>
                </div>
                <div class="context-item">
                    <span class="context-label">Formula:</span>
                    <span id="cellFormula" class="context-value">-</span>
                </div>
                <div class="context-item">
                    <span class="context-label">Sheet:</span>
                    <span id="activeSheet" class="context-value">Loading...</span>
                </div>
                <div class="context-item auto-update">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    <span class="live-indicator">Live</span>
                </div>
            </div>
            
            <!-- Modern Minimalist Chat Messages Area -->
            <div class="chat-messages-container" id="chatMessages">
                <!-- Messages will appear here -->
                <div class="chat-welcome" id="chatWelcome">
                    <div class="welcome-content">
                        <h2>Ask anything about your Excel model</h2>
                        <div class="suggestion-chips">
                            <button class="chip" onclick="sendQuickMessage('What does the current IRR look like?')">What does the current IRR look like?</button>
                            <button class="chip" onclick="sendQuickMessage('Analyze the revenue assumptions')">Analyze the revenue assumptions</button>
                            <button class="chip" onclick="sendQuickMessage('What are the key risks in this model?')">What are the key risks in this model?</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modern Chat Input Area - Fixed Position at Bottom -->
            <div class="chat-input-container-fixed" id="chatInputSection">
                <div class="input-wrapper-modern">
                    <textarea 
                        id="chatInput" 
                        class="chat-input-modern" 
                        placeholder="Ask about your Excel model..."
                        rows="1"
                    ></textarea>
                    <button id="sendMessage" class="send-btn-modern">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <line x1="22" y1="2" x2="11" y2="13"/>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        <!-- End Chat Page -->

    </div>
    <!-- End mainApp -->
    
    <!-- Settings Modal for Enhanced Chat -->
    <div id="chatSettingsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Chat Settings</h3>
                <button class="close-btn" onclick="this.closest('.modal').style.display='none'">√ó</button>
            </div>
            
            <div class="modal-body">
                <div class="setting-group">
                    <label>API Keys</label>
                    <div class="api-key-inputs">
                        <input type="password" id="openaiKey" placeholder="OpenAI API Key (Required)">
                        <small style="color: #666; font-size: 0.85rem; margin-top: 0.5rem; display: block;">
                            Only ChatGPT 4 is currently configured. Other models will be available once API keys are added.
                        </small>
                    </div>
                </div>
                
                <div class="setting-group">
                    <label>
                        <input type="checkbox" id="autoReadExcel" checked>
                        Automatically read Excel context
                    </label>
                </div>
                
                <div class="setting-group">
                    <label>
                        <input type="checkbox" id="streamResponses" checked>
                        Stream responses
                    </label>
                </div>
                
                <div class="setting-group">
                    <label>Max conversation history</label>
                    <input type="number" id="maxHistory" value="20" min="5" max="100">
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="btn secondary" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                <button class="btn primary" onclick="window.enhancedChat.saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    </div>

    <script>
        function showAssumptions() {
            document.getElementById('assumptionsPage').style.display = 'block';
            document.getElementById('chatPage').style.display = 'none';
            document.getElementById('assumptionsTab').classList.add('active');
            document.getElementById('chatTab').classList.remove('active');
            
            // Force visibility of assumptions tabs and re-initialize if needed
            setTimeout(() => {
                const tabsContainer = document.querySelector('.assumptions-tabs');
                if (tabsContainer) {
                    console.log('üîß Ensuring assumptions tabs are visible...');
                    // Force visibility with CSS
                    tabsContainer.style.display = 'flex';
                    tabsContainer.style.visibility = 'visible';
                    tabsContainer.style.opacity = '1';
                    
                    // Re-initialize tab functionality if not already initialized
                    if (!tabsContainer.hasAttribute('data-tabs-initialized')) {
                        initializeAssumptionTabs();
                        tabsContainer.setAttribute('data-tabs-initialized', 'true');
                    }
                }
            }, 100);
        }

        function showChat() {
            document.getElementById('assumptionsPage').style.display = 'none';
            document.getElementById('chatPage').style.display = 'block';
            document.getElementById('assumptionsTab').classList.remove('active');
            document.getElementById('chatTab').classList.add('active');
        }

        // Removed duplicate function - using cleaner implementation below

        // Chat System - Global variables
        let chatContext = null;
        let conversationHistory = [];
        let isReadingExcelFiles = false;
        let userProfilePicture = null;

        // Excel Navigation - Global function for clickable cell references
        async function navigateToExcelCell(cellReference) {
            console.log('üéØ Global navigation triggered for:', cellReference);
            
            if (window.excelNavigator) {
                try {
                    const result = await window.excelNavigator.navigateToCell(cellReference);
                    if (result.success) {
                        console.log('‚úÖ Navigation successful:', result);
                    } else {
                        console.error('‚ùå Navigation failed:', result.error);
                    }
                } catch (error) {
                    console.error('‚ùå Navigation error:', error);
                }
            } else {
                console.error('‚ùå Excel Navigator not available');
            }
        }

        // Make navigation function globally available
        window.navigateToExcelCell = navigateToExcelCell;

        // Global functions for cell preview tooltips
        async function showCellPreview(cellReference, element) {
            if (!window.excelNavigator) return;
            
            try {
                // Create loading tooltip
                const loadingTooltip = document.createElement('div');
                loadingTooltip.className = 'cell-preview-tooltip loading';
                loadingTooltip.textContent = 'Loading...';
                element.appendChild(loadingTooltip);
                
                // Get cell preview data
                const preview = await window.excelNavigator.getCellPreview(cellReference);
                
                // Remove loading tooltip
                loadingTooltip.remove();
                
                if (preview.error) {
                    const errorTooltip = document.createElement('div');
                    errorTooltip.className = 'cell-preview-tooltip error';
                    errorTooltip.textContent = preview.error;
                    element.appendChild(errorTooltip);
                } else {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'cell-preview-tooltip';
                    
                    let content = `<strong>${preview.address}</strong><br>`;
                    if (preview.value !== undefined) {
                        content += `Value: ${preview.value}<br>`;
                    }
                    if (preview.formula && preview.formula !== preview.value) {
                        content += `Formula: ${preview.formula}`;
                    }
                    
                    tooltip.innerHTML = content;
                    element.appendChild(tooltip);
                }
                
            } catch (error) {
                console.error('Error showing cell preview:', error);
            }
        }
        
        function hideCellPreview(element) {
            const tooltip = element.querySelector('.cell-preview-tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }
        
        // Make tooltip functions globally available
        window.showCellPreview = showCellPreview;
        window.hideCellPreview = hideCellPreview;

        function getUserProfilePicture() {
            if (userProfilePicture) return userProfilePicture;
            
            try {
                // Try to get user info from authentication system
                if (window.arcadeusAuth && window.arcadeusAuth.checkAuth) {
                    const user = window.arcadeusAuth.checkAuth();
                    if (user && user.photoURL) {
                        userProfilePicture = user.photoURL;
                        return userProfilePicture;
                    }
                }
                
                // Fallback: try to get from localStorage or other sources
                const storedUser = localStorage.getItem('user');
                if (storedUser) {
                    const userData = JSON.parse(storedUser);
                    if (userData.photoURL) {
                        userProfilePicture = userData.photoURL;
                        return userProfilePicture;
                    }
                }
            } catch (error) {
                console.log('Could not retrieve user profile picture:', error);
            }
            
            // Return null if no profile picture found
            return null;
        }

        function initializeEnhancedChatSystem() {
            console.log('Initializing enhanced chat system...');
            
            // Initialize real-time Excel cell tracking
            initializeExcelCellTracking();
            
            // Initialize the enhanced Excel+AI integration system
            console.log('Using enhanced Excel+AI integration system...');
            initializeEnhancedExcelChat();
            
            // Initialize chat resizer
            initializeChatResizer();
        }

        function initializeExcelCellTracking() {
            console.log('Initializing Excel cell tracking...');
            
            if (typeof Excel === 'undefined') {
                console.log('Excel API not available for cell tracking');
                return;
            }

            try {
                // Set up Excel selection change event
                Excel.run(async (context) => {
                    context.workbook.onSelectionChanged.add(handleCellSelectionChange);
                    await context.sync();
                    console.log('‚úÖ Excel selection change handler registered');
                });

                // Initial cell reading
                updateCurrentCellInfo();
                
                // Also update every 2 seconds as a backup
                setInterval(updateCurrentCellInfo, 2000);
                
            } catch (error) {
                console.error('Failed to initialize Excel cell tracking:', error);
            }
        }

        async function handleCellSelectionChange(event) {
            console.log('üîç Excel selection changed:', event.address);
            await updateCurrentCellInfo();
        }

        async function updateCurrentCellInfo() {
            if (typeof Excel === 'undefined') return;

            try {
                await Excel.run(async (context) => {
                    const workbook = context.workbook;
                    const worksheet = workbook.worksheets.getActiveWorksheet();
                    const selectedRange = workbook.getSelectedRange();
                    
                    // Load the properties we need
                    worksheet.load('name');
                    selectedRange.load(['address', 'values', 'formulas', 'numberFormat']);
                    
                    await context.sync();
                    
                    const cellAddress = selectedRange.address;
                    const cellValue = selectedRange.values[0][0];
                    const cellFormula = selectedRange.formulas[0][0];
                    const sheetName = worksheet.name;
                    
                    // Update the UI
                    updateCellDisplayInfo({
                        address: cellAddress,
                        value: cellValue,
                        formula: cellFormula,
                        sheet: sheetName
                    });
                    
                    console.log(`üìä Current cell: ${cellAddress} = ${cellValue} (${cellFormula})`);
                });
            } catch (error) {
                console.error('Error updating cell info:', error);
                updateCellDisplayInfo({
                    address: 'Error reading cell',
                    value: '-',
                    formula: '-',
                    sheet: 'Unknown'
                });
            }
        }

        function updateCellDisplayInfo(cellInfo) {
            const selectedRange = document.getElementById('selectedRange');
            const cellValue = document.getElementById('cellValue');
            const cellFormula = document.getElementById('cellFormula');
            const activeSheet = document.getElementById('activeSheet');
            
            if (selectedRange) {
                selectedRange.textContent = cellInfo.address || 'No cell selected';
                selectedRange.className = 'context-value selected-cell active';
            }
            
            if (cellValue) {
                // Format the value nicely
                let displayValue = cellInfo.value;
                if (displayValue === null || displayValue === undefined) {
                    displayValue = '(empty)';
                } else if (typeof displayValue === 'number') {
                    // Format numbers nicely
                    if (Math.abs(displayValue) > 1000000) {
                        displayValue = (displayValue / 1000000).toFixed(1) + 'M';
                    } else if (Math.abs(displayValue) > 1000) {
                        displayValue = (displayValue / 1000).toFixed(1) + 'K';
                    } else if (displayValue % 1 !== 0) {
                        displayValue = displayValue.toFixed(2);
                    }
                } else if (typeof displayValue === 'string' && displayValue.length > 30) {
                    displayValue = displayValue.substring(0, 30) + '...';
                }
                cellValue.textContent = displayValue;
            }
            
            if (cellFormula) {
                let displayFormula = cellInfo.formula || '-';
                if (displayFormula && displayFormula !== cellInfo.value && displayFormula.length > 50) {
                    displayFormula = displayFormula.substring(0, 50) + '...';
                }
                cellFormula.textContent = displayFormula === cellInfo.value ? '-' : displayFormula;
            }
            
            if (activeSheet) {
                activeSheet.textContent = cellInfo.sheet || 'Unknown';
            }
            
            // Add visual feedback for live updates
            const liveIndicator = document.querySelector('.live-indicator');
            if (liveIndicator) {
                liveIndicator.style.color = '#00ff00';
                setTimeout(() => {
                    if (liveIndicator) liveIndicator.style.color = '#666';
                }, 1000);
            }
        }

        function initializeBasicChatSystem() {
            console.log('Initializing basic chat system...');
            
            const sendButton = document.getElementById('sendMessage');
            const chatInput = document.getElementById('chatInput');
            
            if (sendButton && chatInput) {
                // Remove any existing listeners
                sendButton.replaceWith(sendButton.cloneNode(true));
                const newSendButton = document.getElementById('sendMessage');
                
                newSendButton.addEventListener('click', handleSendMessageWithExcelContext);
                
                // Handle Enter key in textarea (Shift+Enter for new line)
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleSendMessageWithExcelContext();
                    }
                });
                
                // Auto-expanding textarea
                chatInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
                
                console.log('Basic chat system initialized');
            } else {
                console.error('Chat elements not found');
            }
        }

        async function handleSendMessageWithExcelContext() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message || isReadingExcelFiles) return;
            
            console.log('Sending message with Excel context:', message);
            
            // Clear input
            chatInput.value = '';
            
            // Remove tip section and upgrade card on first message
            removeTipAndUpgradeElements();
            
            // Add user message to chat
            addMessageToChat('user', message);
            
            // Always read Excel context for each message
            console.log('üîç Reading Excel context...');
            await readExcelContextForMessage();
            console.log('üìä Excel context:', chatContext);
            
            // Send message to AI with context
            await sendMessageToOpenAI(message);
        }

        async function readExcelContextForMessage() {
            try {
                console.log('Reading Excel context for message using SafeExcelContext...');
                
                // Use the safe Excel context reader
                if (window.safeExcelContext) {
                    chatContext = await window.safeExcelContext.getChatContext();
                    console.log('‚úÖ Got safe Excel context:', chatContext.summary);
                    return;
                }
                
                // Fallback to old method
                console.warn('SafeExcelContext not available, using fallback');
                if (typeof Excel === 'undefined') {
                    console.log('Excel API not available');
                    chatContext = { error: 'Excel API not available' };
                    return;
                }

                const contextData = await Excel.run(async (context) => {
                    try {
                        // Get current workbook and worksheet
                        const workbook = context.workbook;
                        const worksheet = workbook.worksheets.getActiveWorksheet();
                        const selectedRange = workbook.getSelectedRange();
                        
                        // Load properties in batches
                        workbook.load('name');
                        worksheet.load('name');
                        selectedRange.load(['address', 'values', 'formulas']);
                        
                        await context.sync();
                        
                        const workbookName = workbook.name;
                        const worksheetName = worksheet.name;
                        const selectionInfo = {
                            address: selectedRange.address,
                            values: selectedRange.values,
                            formulas: selectedRange.formulas
                        };
                        
                        // Get all worksheets
                        const worksheets = workbook.worksheets;
                        worksheets.load('items/name');
                        
                        await context.sync();
                        
                        const allSheetsData = {};
                        
                        // Read data from each worksheet (limit to prevent overload)
                        const maxSheets = Math.min(worksheets.items.length, 3); // Reduce to 3 sheets
                        
                        for (let i = 0; i < maxSheets; i++) {
                            const sheet = worksheets.items[i];
                            const sheetName = sheet.name;
                            
                            try {
                                const usedRange = sheet.getUsedRangeOrNullObject();
                                usedRange.load(['address', 'values', 'formulas']);
                                
                                await context.sync();
                                
                                if (!usedRange.isNullObject) {
                                    // Limit data size significantly
                                    const values = usedRange.values;
                                    const formulas = usedRange.formulas;
                                    
                                    // Only take first 20 rows and 10 columns
                                    const limitedValues = values.slice(0, 20).map(row => row.slice(0, 10));
                                    const limitedFormulas = formulas.slice(0, 20).map(row => row.slice(0, 10));
                                    
                                    allSheetsData[sheetName] = {
                                        address: usedRange.address,
                                        values: limitedValues,
                                        formulas: limitedFormulas,
                                        rowCount: values.length,
                                        columnCount: values[0]?.length || 0
                                    };
                                }
                            } catch (sheetError) {
                                console.warn(`Could not read sheet ${sheetName}:`, sheetError);
                                allSheetsData[sheetName] = { error: 'Could not read sheet data' };
                            }
                        }
                        
                        return {
                            workbook: workbookName,
                            activeSheet: worksheetName,
                            selectedRange: selectionInfo,
                            sheets: allSheetsData,
                            timestamp: new Date().toISOString()
                        };
                        
                    } catch (innerError) {
                        console.error('Inner Excel API error:', innerError);
                        throw innerError;
                    }
                });
                
                chatContext = contextData;
                console.log('‚úÖ Excel context updated:', chatContext);
                
                // Update UI context display
                updateExcelContextDisplay(contextData);
                
            } catch (error) {
                console.error('‚ùå Error reading Excel context:', error);
                chatContext = { 
                    error: error.message || 'Failed to read Excel context',
                    fallbackData: {
                        workbook: 'Unknown',
                        activeSheet: 'Unknown',
                        selectedRange: { address: 'Unknown', values: [], formulas: [] },
                        sheets: {},
                        timestamp: new Date().toISOString()
                    }
                };
                
                // Still update UI with fallback data
                updateExcelContextDisplay(chatContext.fallbackData);
            }
        }

        function updateExcelContextDisplay(context) {
            const workbookName = document.getElementById('workbookName');
            const activeSheet = document.getElementById('activeSheet');
            const selectedRange = document.getElementById('selectedRange');
            const selectionIndicator = document.getElementById('selectionIndicator');
            
            if (workbookName) workbookName.textContent = context.workbook || 'N/A';
            if (activeSheet) activeSheet.textContent = context.activeSheet || 'N/A';
            if (selectedRange) selectedRange.textContent = context.selectedRange?.address || 'N/A';
            if (selectionIndicator) selectionIndicator.textContent = `Selected: ${context.selectedRange?.address || 'None'}`;
        }

        function analyzeExcelDataForQuery(userMessage, context) {
            if (!context || !context.sheets) {
                return {
                    summary: 'No Excel data available to analyze.',
                    detailedData: {}
                };
            }

            const query = userMessage.toLowerCase();
            
            // Intelligent analysis based on question intent
            let analysisResults = {
                primaryMetric: null,
                relatedMetrics: [],
                keyFindings: [],
                contextualData: {},
                summary: ''
            };

            // Detect what financial metric the user is asking about
            const metricKeywords = {
                moic: ['moic', 'multiple', 'money on invested capital', 'cash on cash', 'return multiple'],
                irr: ['irr', 'internal rate', 'return rate', 'discount rate'],
                npv: ['npv', 'net present value', 'present value'],
                revenue: ['revenue', 'sales', 'income', 'turnover', 'top line'],
                ebitda: ['ebitda', 'earnings', 'operating income', 'cash flow'],
                debt: ['debt', 'loan', 'borrowing', 'financing', 'leverage'],
                equity: ['equity', 'investment', 'capital', 'contribution'],
                exit: ['exit', 'sale', 'disposal', 'terminal', 'exit value'],
                fcf: ['free cash flow', 'fcf', 'cash flow', 'cash generation']
            };

            // Find primary metric being discussed
            for (const [metric, keywords] of Object.entries(metricKeywords)) {
                if (keywords.some(keyword => query.includes(keyword))) {
                    analysisResults.primaryMetric = metric.toUpperCase();
                    break;
                }
            }

            // If asking about MOIC specifically, do comprehensive MOIC analysis
            if (analysisResults.primaryMetric === 'MOIC' || query.includes('moic')) {
                // Check if user is providing MOIC data manually
                if (detectUserProvidedMOICData(userMessage)) {
                    return analyzeUserProvidedMOIC(userMessage);
                }
                return analyzeMOICComprehensively(context, userMessage);
            }

            // If asking about IRR, do IRR analysis
            if (analysisResults.primaryMetric === 'IRR' || query.includes('irr')) {
                return analyzeIRRComprehensively(context, userMessage);
            }

            // For other metrics, do general financial analysis
            return analyzeGeneralFinancialMetric(context, userMessage, analysisResults.primaryMetric);
        }

        function analyzeMOICComprehensively(context, userMessage) {
            let moicFindings = {
                moicValue: null,
                moicCell: null,
                exitValue: null,
                investedCapital: null,
                keyDrivers: [],
                analysis: ''
            };

            // Search all sheets for MOIC-related data
            Object.entries(context.sheets).forEach(([sheetName, sheetData]) => {
                if (!sheetData.values || !sheetData.formulas) return;

                for (let row = 0; row < Math.min(sheetData.values.length, 100); row++) {
                    for (let col = 0; col < Math.min(sheetData.values[row]?.length || 0, 20); col++) {
                        const cellValue = sheetData.values[row][col];
                        const cellFormula = sheetData.formulas[row][col];
                        const cellAddress = `${sheetName}!${String.fromCharCode(65 + col)}${row + 1}`;
                        
                        if (cellValue !== null && cellValue !== '') {
                            const cellText = String(cellValue).toLowerCase();
                            const formulaText = String(cellFormula || '').toLowerCase();
                            
                            // Look for MOIC label and value
                            if (cellText.includes('moic') || cellText.includes('multiple') || cellText.includes('cash on cash')) {
                                // Check adjacent cells for the actual MOIC value
                                const rightCell = sheetData.values[row][col + 1];
                                const belowCell = sheetData.values[row + 1]?.[col];
                                
                                if (typeof rightCell === 'number' && rightCell > 0.1 && rightCell < 100) {
                                    moicFindings.moicValue = rightCell;
                                    moicFindings.moicCell = `${sheetName}!${String.fromCharCode(66 + col)}${row + 1}`;
                                } else if (typeof belowCell === 'number' && belowCell > 0.1 && belowCell < 100) {
                                    moicFindings.moicValue = belowCell;
                                    moicFindings.moicCell = `${sheetName}!${String.fromCharCode(65 + col)}${row + 2}`;
                                }
                            }

                            // Look for exit value / terminal value
                            if ((cellText.includes('exit') && cellText.includes('value')) || 
                                cellText.includes('terminal value') || 
                                cellText.includes('enterprise value') ||
                                cellText.includes('sale price')) {
                                
                                const rightCell = sheetData.values[row][col + 1];
                                const belowCell = sheetData.values[row + 1]?.[col];
                                
                                if (typeof rightCell === 'number' && rightCell > 1000000) { // Assuming values > 1M
                                    moicFindings.exitValue = rightCell;
                                } else if (typeof belowCell === 'number' && belowCell > 1000000) {
                                    moicFindings.exitValue = belowCell;
                                }
                            }

                            // Look for initial investment / equity contribution
                            if ((cellText.includes('equity') && cellText.includes('contribution')) ||
                                cellText.includes('initial investment') ||
                                cellText.includes('invested capital') ||
                                (cellText.includes('investment') && !cellText.includes('return'))) {
                                
                                const rightCell = sheetData.values[row][col + 1];
                                const belowCell = sheetData.values[row + 1]?.[col];
                                
                                if (typeof rightCell === 'number' && rightCell > 100000) { // Assuming values > 100K
                                    moicFindings.investedCapital = rightCell;
                                } else if (typeof belowCell === 'number' && belowCell > 100000) {
                                    moicFindings.investedCapital = belowCell;
                                }
                            }

                            // Look for potential numeric MOIC values (standalone numbers in typical range)
                            if (typeof cellValue === 'number' && cellValue > 1 && cellValue < 20 && !moicFindings.moicValue) {
                                // Check if nearby cells have MOIC-related text
                                const contextCells = [
                                    sheetData.values[row - 1]?.[col], // Above
                                    sheetData.values[row][col - 1],   // Left
                                    sheetData.values[row + 1]?.[col], // Below
                                    sheetData.values[row][col + 1]    // Right
                                ];
                                
                                const hasContextualText = contextCells.some(contextCell => {
                                    if (!contextCell) return false;
                                    const contextText = String(contextCell).toLowerCase();
                                    return contextText.includes('moic') || contextText.includes('multiple') || 
                                           contextText.includes('return') || contextText.includes('cash');
                                });

                                if (hasContextualText) {
                                    moicFindings.moicValue = cellValue;
                                    moicFindings.moicCell = cellAddress;
                                }
                            }
                        }
                    }
                }
            });

            // Generate intelligent analysis
            let analysis = '';
            
            if (moicFindings.moicValue !== null) {
                const moicText = moicFindings.moicValue.toFixed(2) + 'x';
                analysis += `MOIC Analysis:\n\n`;
                analysis += `üìä MOIC Value: ${moicText} (located at ${moicFindings.moicCell})\n\n`;
                
                // Analyze if MOIC is high/low and why
                if (userMessage.toLowerCase().includes('high') && moicFindings.moicValue > 2.5) {
                    analysis += `üîç Why MOIC is HIGH (${moicText}):\n`;
                    analysis += `‚Ä¢ Strong exit multiple or valuation increase\n`;
                    if (moicFindings.exitValue && moicFindings.investedCapital) {
                        analysis += `‚Ä¢ Exit Value: ${formatCurrency(moicFindings.exitValue)}\n`;
                        analysis += `‚Ä¢ Invested Capital: ${formatCurrency(moicFindings.investedCapital)}\n`;
                        analysis += `‚Ä¢ Multiple = ${formatCurrency(moicFindings.exitValue)} √∑ ${formatCurrency(moicFindings.investedCapital)} = ${moicText}\n`;
                    }
                    analysis += `‚Ä¢ Likely drivers: Strong business performance, market expansion, multiple arbitrage, operational improvements\n`;
                } else if (userMessage.toLowerCase().includes('low') && moicFindings.moicValue < 2.0) {
                    analysis += `üîç Why MOIC is LOW (${moicText}):\n`;
                    analysis += `‚Ä¢ Conservative exit valuation or market conditions\n`;
                    analysis += `‚Ä¢ High initial investment relative to returns\n`;
                    analysis += `‚Ä¢ Consider reviewing growth assumptions and exit multiple\n`;
                }
                
                analysis += `\nüìà Key Value Drivers to Review:\n`;
                analysis += `‚Ä¢ Exit valuation assumptions (P/E, EV/EBITDA multiples)\n`;
                analysis += `‚Ä¢ Revenue growth rates and market penetration\n`;
                analysis += `‚Ä¢ Margin expansion opportunities\n`;
                analysis += `‚Ä¢ Operational efficiency improvements\n`;
                analysis += `‚Ä¢ Debt paydown reducing equity needs\n`;
                
            } else {
                analysis += `ü§î I couldn't locate the MOIC value in your Excel model automatically.\n\n`;
                analysis += `**Let's work together to find it!**\n\n`;
                analysis += `Could you help me by:\n`;
                analysis += `1Ô∏è‚É£ **Tell me the MOIC value** - What does your model show for MOIC? (e.g., "2.5x")\n`;
                analysis += `2Ô∏è‚É£ **Share the exit value** - What's the projected exit/terminal value?\n`;
                analysis += `3Ô∏è‚É£ **Share the invested capital** - How much equity was initially invested?\n\n`;
                analysis += `üí° *Once you provide these numbers, I can analyze why the MOIC is high/low and suggest improvements!*\n\n`;
                analysis += `üìä **Available sheets:** ${Object.keys(context.sheets).join(', ')}\n`;
                analysis += `üí¨ **Just type something like:** "The MOIC is 3.2x, exit value is $150M, invested $47M"\n`;
            }

            return {
                summary: analysis,
                detailedData: moicFindings
            };
        }

        function analyzeIRRComprehensively(context, userMessage) {
            // Similar comprehensive analysis for IRR
            let analysis = `üîç IRR Analysis:\n\nSearching for IRR calculations and cash flow patterns...\n`;
            analysis += `This would analyze cash flow timing, discount rates, and return drivers.\n`;
            return { summary: analysis, detailedData: {} };
        }

        function analyzeGeneralFinancialMetric(context, userMessage, primaryMetric) {
            let analysis = `üîç Financial Analysis:\n\nAnalyzing ${primaryMetric || 'financial metrics'} in your model...\n`;
            return { summary: analysis, detailedData: {} };
        }

        function detectUserProvidedMOICData(message) {
            const msg = message.toLowerCase();
            
            // Look for patterns where user provides MOIC data
            const patterns = [
                /moic.*is.*(\d+\.?\d*)x?/,
                /(\d+\.?\d*)x.*moic/,
                /exit.*(\d+)/,
                /invested.*(\d+)/,
                /terminal.*value.*(\d+)/,
                /(\d+\.?\d*)x.*exit.*(\d+)/
            ];
            
            return patterns.some(pattern => pattern.test(msg));
        }

        function analyzeUserProvidedMOIC(message) {
            const msg = message.toLowerCase();
            let analysis = `‚úÖ **Great! Let me analyze the MOIC data you provided:**\n\n`;
            
            // Extract MOIC value
            const moicMatch = msg.match(/(?:moic.*is.*|^.*?)(\d+\.?\d*)x?/);
            const exitMatch = msg.match(/exit.*?(\d+(?:\.\d+)?)\s*([mb]?)/);
            const investedMatch = msg.match(/invest.*?(\d+(?:\.\d+)?)\s*([mb]?)/);
            
            let moicValue = null;
            let exitValue = null;
            let investedValue = null;
            
            if (moicMatch) {
                moicValue = parseFloat(moicMatch[1]);
            }
            
            if (exitMatch) {
                exitValue = parseFloat(exitMatch[1]);
                const unit = exitMatch[2];
                if (unit === 'm') exitValue *= 1000000;
                if (unit === 'b') exitValue *= 1000000000;
            }
            
            if (investedMatch) {
                investedValue = parseFloat(investedMatch[1]);
                const unit = investedMatch[2];
                if (unit === 'm') investedValue *= 1000000;
                if (unit === 'b') investedValue *= 1000000000;
            }
            
            // Calculate missing values if possible
            if (moicValue && exitValue && !investedValue) {
                investedValue = exitValue / moicValue;
            } else if (moicValue && investedValue && !exitValue) {
                exitValue = moicValue * investedValue;
            } else if (!moicValue && exitValue && investedValue) {
                moicValue = exitValue / investedValue;
            }
            
            if (moicValue) {
                const moicText = moicValue.toFixed(2) + 'x';
                analysis += `üìä **MOIC Analysis: ${moicText}**\n\n`;
                
                if (exitValue && investedValue) {
                    analysis += `üí∞ **Financial Breakdown:**\n`;
                    analysis += `‚Ä¢ Exit Value: ${formatCurrency(exitValue)}\n`;
                    analysis += `‚Ä¢ Invested Capital: ${formatCurrency(investedValue)}\n`;
                    analysis += `‚Ä¢ Multiple: ${formatCurrency(exitValue)} √∑ ${formatCurrency(investedValue)} = ${moicText}\n\n`;
                }
                
                // Analyze if MOIC is high/low
                if (moicValue >= 3.0) {
                    analysis += `üöÄ **Why this MOIC is HIGH (${moicText}):**\n`;
                    analysis += `‚Ä¢ **Excellent return** - This is above typical PE/VC target returns\n`;
                    analysis += `‚Ä¢ **Strong value creation** - Significant multiple expansion likely\n`;
                    analysis += `‚Ä¢ **Key drivers probably include:**\n`;
                    analysis += `  - Revenue growth acceleration\n`;
                    analysis += `  - Margin expansion and operational improvements\n`;
                    analysis += `  - Market multiple expansion\n`;
                    analysis += `  - Successful market penetration/expansion\n\n`;
                    
                    analysis += `‚ùì **Follow-up questions for you:**\n`;
                    analysis += `‚Ä¢ What's driving the revenue growth in your model?\n`;
                    analysis += `‚Ä¢ What exit multiple are you assuming (e.g., EV/EBITDA)?\n`;
                    analysis += `‚Ä¢ Are there any operational improvements baked in?\n`;
                    
                } else if (moicValue >= 2.0) {
                    analysis += `üëç **This MOIC is SOLID (${moicText}):**\n`;
                    analysis += `‚Ä¢ **Good return** - Meets typical investment thresholds\n`;
                    analysis += `‚Ä¢ **Reasonable expectations** - Not overly aggressive\n`;
                    analysis += `‚Ä¢ **Value creation through:**\n`;
                    analysis += `  - Steady business growth\n`;
                    analysis += `  - Some operational improvements\n`;
                    analysis += `  - Market expansion\n\n`;
                    
                    analysis += `üí° **Potential upside opportunities:**\n`;
                    analysis += `‚Ä¢ Could you accelerate growth further?\n`;
                    analysis += `‚Ä¢ Any untapped operational efficiency gains?\n`;
                    analysis += `‚Ä¢ Market expansion possibilities?\n`;
                    
                } else {
                    analysis += `‚ö†Ô∏è **This MOIC seems LOW (${moicText}):**\n`;
                    analysis += `‚Ä¢ **Below typical targets** - Most PE/VC aim for 2.5x+ MOIC\n`;
                    analysis += `‚Ä¢ **Consider reviewing:**\n`;
                    analysis += `  - Growth assumptions (too conservative?)\n`;
                    analysis += `  - Exit multiple assumptions\n`;
                    analysis += `  - Operational improvement opportunities\n`;
                    analysis += `  - Market expansion potential\n\n`;
                    
                    analysis += `üîç **Questions to explore:**\n`;
                    analysis += `‚Ä¢ What's limiting the growth in your model?\n`;
                    analysis += `‚Ä¢ Are your exit multiples conservative?\n`;
                    analysis += `‚Ä¢ Any additional value creation levers?\n`;
                }
                
            } else {
                analysis += `ü§î I couldn't extract clear MOIC numbers from your message.\n\n`;
                analysis += `Could you try again with a format like:\n`;
                analysis += `"MOIC is 2.8x, exit value $120M, invested $43M"\n`;
            }
            
            return {
                summary: analysis,
                detailedData: { moicValue, exitValue, investedValue }
            };
        }

        function formatCurrency(value) {
            if (value >= 1000000000) {
                return `$${(value / 1000000000).toFixed(1)}B`;
            } else if (value >= 1000000) {
                return `$${(value / 1000000).toFixed(1)}M`;
            } else if (value >= 1000) {
                return `$${(value / 1000).toFixed(0)}K`;
            } else {
                return `$${value.toFixed(0)}`;
            }
        }

        function sendQuickMessage(message) {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.value = message;
                // Use the same working function that manual typing uses
                handleUserQuery(message);
            }
        }

        function clearChatHistory() {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            conversationHistory = [];
            chatContext = null;
            console.log('Chat history cleared');
        }

        function initializeChatResizer() {
            const resizer = document.getElementById('chatResizer');
            const chatMessages = document.getElementById('chatMessages');
            const chatInputSection = document.getElementById('chatInputSection');
            
            if (!resizer || !chatMessages || !chatInputSection) {
                console.error('Resizer elements not found');
                return;
            }
            
            let isResizing = false;
            let startY = 0;
            let startInputHeight = 0;
            let startMessagesHeight = 0;
            
            resizer.addEventListener('mousedown', function(e) {
                isResizing = true;
                startY = e.clientY;
                startInputHeight = chatInputSection.offsetHeight;
                startMessagesHeight = chatMessages.offsetHeight;
                
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const newInputHeight = startInputHeight - deltaY;
                const newMessagesHeight = startMessagesHeight + deltaY;
                
                // Set minimum and maximum heights
                const minInputHeight = 140;
                const maxInputHeight = 400;
                const minMessagesHeight = 200;
                
                if (newInputHeight >= minInputHeight && 
                    newInputHeight <= maxInputHeight && 
                    newMessagesHeight >= minMessagesHeight) {
                    
                    chatInputSection.style.height = newInputHeight + 'px';
                    chatMessages.style.height = newMessagesHeight + 'px';
                }
                
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
            
            console.log('Chat resizer initialized');
        }

        async function handleSendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message || isReadingExcelFiles) return;
            
            console.log('Sending message:', message);
            
            // Clear input
            chatInput.value = '';
            
            // Remove tip section and upgrade card on first message
            removeTipAndUpgradeElements();
            
            // Add user message to chat
            addMessageToChat('user', message);
            
            // If this is the first message, read Excel files first
            if (!chatContext) {
                await readExcelFilesWithAnimation();
            }
            
            // Send message to OpenAI
            await sendMessageToOpenAI(message);
        }

        function removeTipAndUpgradeElements() {
            const tipSection = document.querySelector('.chat-tip-section');
            const upgradeCard = document.querySelector('.upgrade-card');
            
            if (tipSection) {
                tipSection.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                tipSection.style.opacity = '0';
                tipSection.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (tipSection.parentNode) {
                        tipSection.parentNode.removeChild(tipSection);
                    }
                }, 300);
            }
            
            if (upgradeCard) {
                upgradeCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                upgradeCard.style.opacity = '0';
                upgradeCard.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    if (upgradeCard.parentNode) {
                        upgradeCard.parentNode.removeChild(upgradeCard);
                    }
                }, 300);
            }
        }

        async function readExcelFilesWithAnimation() {
            if (isReadingExcelFiles) return;
            
            isReadingExcelFiles = true;
            console.log('Starting Excel file reading...');
            
            // Add system message with loading bar
            const loadingMessage = addLoadingMessageToChat('Reading your Excel model files to understand the context...');
            
            const sheetsToRead = [
                { name: 'Assumptions', delay: 1000 },
                { name: 'P&L Statement', delay: 1500 },
                { name: 'Free Cash Flow', delay: 1200 },
                { name: 'Debt Model', delay: 1000 },
                { name: 'Valuation Summary', delay: 800 }
            ];
            
            let contextData = {};
            const totalSheets = sheetsToRead.length;
            
            try {
                for (let i = 0; i < sheetsToRead.length; i++) {
                    const sheet = sheetsToRead[i];
                    const progress = ((i + 1) / totalSheets) * 100;
                    
                    // Update loading message
                    updateLoadingMessage(loadingMessage, `Reading ${sheet.name}...`, progress);
                    
                    // Simulate reading delay
                    await new Promise(resolve => setTimeout(resolve, sheet.delay));
                    
                    // Try to read the actual Excel data
                    try {
                        const sheetData = await readExcelSheet(sheet.name);
                        contextData[sheet.name] = sheetData;
                    } catch (error) {
                        console.warn(`Could not read ${sheet.name}:`, error);
                        contextData[sheet.name] = { error: error.message };
                    }
                }
                
                // Store context
                chatContext = contextData;
                
                // Final update to show completion
                updateLoadingMessage(loadingMessage, 'Analysis complete. Your model context is now available.', 100, true);
                
            } catch (error) {
                console.error('Error reading Excel files:', error);
                updateLoadingMessage(loadingMessage, 'Error reading Excel files. I\'ll still try to help based on your input.', 100, true);
            }
            
            isReadingExcelFiles = false;
        }

        async function readExcelSheet(sheetName) {
            return new Promise(async (resolve, reject) => {
                try {
                    await Excel.run(async (context) => {
                        // Try to access the worksheet
                        const worksheet = context.workbook.worksheets.getItemOrNullObject(sheetName);
                        worksheet.load(['name']);
                        
                        await context.sync();
                        
                        if (worksheet.isNullObject) {
                            reject(new Error(`Sheet ${sheetName} not found`));
                            return;
                        }
                        
                        // Get used range
                        const usedRange = worksheet.getUsedRangeOrNullObject();
                        usedRange.load(['values', 'formulas', 'address', 'text']);
                        
                        await context.sync();
                        
                        if (usedRange.isNullObject) {
                            resolve({
                                sheetName: sheetName,
                                status: 'empty',
                                message: 'Sheet exists but has no data'
                            });
                            return;
                        }
                        
                        // Process the data comprehensively
                        const values = usedRange.values;
                        const formulas = usedRange.formulas;
                        const text = usedRange.text;
                        
                        // Extract meaningful data structure
                        const dataStructure = analyzeSheetStructure(values, text, sheetName);
                        
                        const processedData = {
                            sheetName: sheetName,
                            range: usedRange.address,
                            rowCount: values.length,
                            columnCount: values[0] ? values[0].length : 0,
                            rawData: values, // Complete data for AI analysis
                            textData: text, // Formatted text values
                            dataStructure: dataStructure, // Structured interpretation
                            hasFormulas: formulas.some(row => row.some(cell => cell && cell.startsWith('='))),
                            keyMetrics: extractKeyMetrics(values, text, sheetName),
                            status: 'success'
                        };
                        
                        resolve(processedData);
                    });
                } catch (error) {
                    reject(error);
                }
            });
        }

        function analyzeSheetStructure(values, text, sheetName) {
            // Analyze the structure based on sheet type
            const structure = {
                headers: [],
                dataRows: [],
                summary: `${sheetName} contains ${values.length} rows and ${values[0]?.length || 0} columns`
            };

            if (values.length > 0) {
                // First row often contains headers
                structure.headers = text[0] || values[0] || [];
                
                // Analyze data patterns
                if (values.length > 1) {
                    structure.dataRows = text.slice(1, Math.min(11, text.length)); // First 10 data rows
                }
            }

            return structure;
        }

        function extractKeyMetrics(values, text, sheetName) {
            const metrics = [];
            
            // Look for common financial metrics based on sheet name
            const searchPatterns = {
                'Assumptions': ['Deal Value', 'LTV', 'Transaction Fee', 'Discount Rate', 'WACC'],
                'P&L Statement': ['Revenue', 'EBITDA', 'Net Income', 'Gross Profit'],
                'Free Cash Flow': ['FCF', 'Cash Flow', 'NPV', 'IRR', 'MOIC'],
                'Debt Model': ['Interest Rate', 'Debt Amount', 'Principal', 'Interest Payment'],
                'Valuation Summary': ['Enterprise Value', 'Equity Value', 'Multiple', 'Valuation']
            };

            const patterns = searchPatterns[sheetName] || [];
            
            // Search through the data for these patterns
            for (let i = 0; i < values.length && i < 50; i++) { // Search first 50 rows
                for (let j = 0; j < (values[i]?.length || 0); j++) {
                    const cellValue = String(text[i]?.[j] || values[i]?.[j] || '').toLowerCase();
                    
                    for (const pattern of patterns) {
                        if (cellValue.includes(pattern.toLowerCase())) {
                            // Try to find the corresponding value
                            const value = values[i]?.[j + 1] || values[i + 1]?.[j];
                            if (value !== null && value !== undefined && value !== '') {
                                metrics.push({
                                    label: pattern,
                                    value: value,
                                    location: `Row ${i + 1}, Col ${j + 1}`
                                });
                            }
                        }
                    }
                }
            }

            return metrics;
        }

        /**
         * Determine if message should be handled by Excel Action Agent
         */
        async function shouldUseActionAgent(message) {
            const lower = message.toLowerCase();
            
            // Action keywords that indicate direct Excel manipulation
            const actionKeywords = [
                'change color', 'change colour',
                'format', 'style',
                'make bold', 'make italic',
                'add formula', 'create formula',
                'update value', 'change value',
                'delete', 'remove',
                'insert', 'add row', 'add column',
                'create chart', 'make chart',
                'sort', 'filter'
            ];
            
            // Color-specific requests
            const colorRequests = [
                'green', 'red', 'blue', 'yellow', 'orange', 'purple', 'pink'
            ];
            
            // Check for action keywords
            const hasActionKeyword = actionKeywords.some(keyword => lower.includes(keyword));
            
            // Check for imperative verbs with Excel terms
            const imperativePatterns = [
                /^(change|update|format|style|color|make)/,
                /(header|cell|range|row|column|chart)/
            ];
            
            const hasImperativePattern = imperativePatterns.some(pattern => pattern.test(lower));
            
            // Check for color requests
            const hasColorRequest = colorRequests.some(color => 
                lower.includes(color) && (lower.includes('change') || lower.includes('make'))
            );
            
            return hasActionKeyword || hasImperativePattern || hasColorRequest;
        }

        async function sendMessageToOpenAI(userMessage) {
            try {
                // Remove thinking message and create streaming message
                const existingThinking = document.querySelector('.chat-message.assistant-message .message-text');
                if (existingThinking && existingThinking.textContent === 'Analyzing your Excel model...') {
                    existingThinking.closest('.chat-message').remove();
                }
                
                // Create streaming message container
                const streamingMessage = createStreamingMessageContainer();
                
                // Check if this is an Excel action request first
                if (window.directExcelActions && window.directExcelActions.isExcelActionRequest(userMessage)) {
                    console.log('üéØ Using Direct Excel Actions for this request');
                    
                    updateStreamingMessage(streamingMessage, 'üîß Performing Excel action...', false);
                    
                    try {
                        const actionResult = await window.directExcelActions.executeAction(userMessage);
                        const formattedResponse = window.directExcelActions.formatResponse(actionResult);
                        
                        updateStreamingMessage(streamingMessage, formattedResponse, true);
                        return;
                    } catch (actionError) {
                        console.error('Direct Excel action error:', actionError);
                        updateStreamingMessage(streamingMessage, '‚ö†Ô∏è Excel action failed, falling back to analysis...', false);
                        // Continue with normal processing
                    }
                }
                
                // Try Enhanced Excel Agent for complex requests
                else if (window.EnhancedExcelAgent && (userMessage.toLowerCase().includes('analyze') || userMessage.toLowerCase().includes('what'))) {
                    console.log('üöÄ Using Enhanced Excel Agent for analysis');
                    
                    updateStreamingMessage(streamingMessage, 'üß† Analyzing with AI agent...', false);
                    
                    try {
                        // Initialize enhanced agent if not already done
                        if (!window.enhancedAgent) {
                            window.enhancedAgent = new window.EnhancedExcelAgent();
                            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for initialization
                        }
                        
                        const agentResult = await window.enhancedAgent.processRequest(userMessage, {
                            excelContext: chatContext,
                            selectedRange: null
                        });
                        
                        let formattedResponse;
                        if (agentResult.success) {
                            if (agentResult.type === 'analyze_data_success') {
                                formattedResponse = `<div class="response-summary">${agentResult.message}</div>`;
                                if (agentResult.insights && agentResult.insights.length > 0) {
                                    formattedResponse += `<h4>üí° Key Insights:</h4><ul>`;
                                    agentResult.insights.forEach(insight => {
                                        formattedResponse += `<li><strong>${insight.type}:</strong> ${insight.message}</li>`;
                                    });
                                    formattedResponse += `</ul>`;
                                }
                            } else {
                                formattedResponse = `<div class="response-summary">${agentResult.message}</div>`;
                            }
                        } else {
                            formattedResponse = `<div class="action-error">${agentResult.message}</div>`;
                        }
                        
                        updateStreamingMessage(streamingMessage, formattedResponse, true);
                        return;
                    } catch (agentError) {
                        console.error('Enhanced agent error:', agentError);
                        updateStreamingMessage(streamingMessage, '‚ö†Ô∏è Agent analysis failed, falling back to standard analysis...', false);
                        // Continue with normal processing
                    }
                }
                
                // Fallback: Basic action agent if other systems not available
                else if (await shouldUseActionAgent(userMessage)) {
                    console.log('ü§ñ Using Basic Excel Action Agent for this request');
                    
                    updateStreamingMessage(streamingMessage, 'üîß Performing Excel action...', false);
                    
                    try {
                        const actionResult = await window.excelActionAgent.processActionRequest(userMessage, chatContext);
                        const formattedResponse = window.excelActionAgent.formatActionResponse(actionResult);
                        
                        updateStreamingMessage(streamingMessage, formattedResponse, true);
                        return;
                    } catch (actionError) {
                        console.error('Action agent error:', actionError);
                        updateStreamingMessage(streamingMessage, '‚ö†Ô∏è Action failed, falling back to analysis...', false);
                        // Continue with normal AI processing
                    }
                }
                
                // Analyze the user message using intelligent financial analysis
                const intelligentAnalysis = analyzeExcelDataForQuery(userMessage, chatContext);
                
                console.log('Intelligent analysis results:', intelligentAnalysis);
                
                // If we have a complete analysis (like for MOIC), use it directly
                if (intelligentAnalysis.summary && intelligentAnalysis.summary.includes('MOIC Analysis:')) {
                    // For MOIC questions, we already have the full analysis
                    fullResponse = intelligentAnalysis.summary;
                    updateStreamingMessage(streamingMessage, fullResponse, true);
                    success = true;
                    
                    console.log('Using direct intelligent analysis for MOIC question');
                } else {
                    // For other questions, send the analysis to AI for further processing
                    let contextPrompt = '';
                    
                    if (chatContext && !chatContext.error) {
                        contextPrompt = `\n\nEXCEL MODEL ANALYSIS RESULTS:
${intelligentAnalysis.summary}

EXCEL CONTEXT:
- Workbook: ${chatContext.workbook}
- Active Sheet: ${chatContext.activeSheet}
- Selected Range: ${chatContext.selectedRange?.address || 'None'}
- Available Sheets: ${Object.keys(chatContext.sheets || {}).join(', ')}

CONVERSATION HISTORY:
${conversationHistory.slice(-10).map(msg => `${msg.role}: ${msg.content}`).join('\n')}`;
                    } else {
                        const errorMsg = chatContext?.error || 'Unable to access Excel context';
                        contextPrompt = `\n\nNote: ${errorMsg}. I'll provide general M&A financial modeling assistance.

CONVERSATION HISTORY:
${conversationHistory.slice(-10).map(msg => `${msg.role}: ${msg.content}`).join('\n')}`;
                    }
                    
                    const fullPrompt = `You are an expert M&A financial analyst helping with an Excel-based deal model.

RESPONSE FORMAT REQUIREMENT:
For financial analysis questions about MOIC, IRR, returns, or metrics, respond with ONLY a structured JSON object:
{
  "summary": "Brief overview of findings",
  "key_metrics": [
    {"metric": "MOIC", "value": "3.2x", "location": "FCF!B23", "interpretation": "Strong", "context": "Driven by..."}
  ],
  "insights": [
    {"title": "Key Finding", "content": "Details", "impact": "high", "type": "positive"}
  ],
  "recommendations": [
    {"priority": "high", "action": "What to do", "rationale": "Why it matters"}
  ]
}

For other questions, provide clear conversational responses without excessive markdown.
Avoid using ### headers, **bold everywhere**, and LaTeX formatting.

${contextPrompt}

IMPORTANT INSTRUCTIONS:
- Use the analysis results provided above as your primary source of information
- Always reference specific cells, sheets, and values when discussing the model
- Build upon the financial analysis provided rather than repeating it
- If specific metrics or values are found, explain the implications and provide recommendations
- Be specific about which cells contain the metrics being discussed

USER MESSAGE: ${userMessage}`;
                    
                    console.log('=== CHAT DEBUG INFO ===');
                    console.log('User message:', userMessage);
                    console.log('Excel context available:', !!(chatContext && !chatContext.error));
                    console.log('Sending prompt to Netlify function...');
                    console.log('Prompt length:', fullPrompt.length);
                    
                    try {
                        // Determine the correct endpoint URL based on environment
                        const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                        const apiEndpoint = isLocal 
                            ? 'http://localhost:8888/.netlify/functions/chat' 
                            : '/.netlify/functions/chat';
                        
                        console.log('Using endpoint:', apiEndpoint);
                        
                        // Call Netlify function which has the API key
                        const response = await fetch(apiEndpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                message: fullPrompt,
                                autoFillMode: false,
                                batchType: 'chat_response',
                                systemPrompt: 'You are an expert M&A financial analyst. Provide clear, actionable insights about the deal model. Reference specific data from the Excel sheets when available.',
                                temperature: 0.7,
                                maxTokens: 2000
                            })
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('Netlify function error:', response.status, errorText);
                            throw new Error(`API error: ${response.status} - ${errorText}`);
                        }

                        const result = await response.json();
                        console.log('Netlify function response:', result);
                        
                        // Extract response - the Netlify function returns content directly
                        if (result.content) {
                            fullResponse = result.content;
                        } else if (result.response) {
                            fullResponse = result.response;
                        } else if (result.choices && result.choices[0] && result.choices[0].message) {
                            fullResponse = result.choices[0].message.content;
                        } else if (result.message) {
                            fullResponse = result.message;
                        } else {
                            console.error('Unexpected response format:', result);
                            throw new Error('Unexpected response format from API');
                        }
                        
                        if (!fullResponse || fullResponse.trim() === '') {
                            throw new Error('Empty response from API');
                        }
                        
                        console.log('Received response:', fullResponse.substring(0, 200) + '...');
                        
                        // Update streaming message with full response
                        updateStreamingMessage(streamingMessage, fullResponse, true);
                        success = true;
                        
                    } catch (apiError) {
                        console.error('API call failed:', apiError);
                        
                        // Use intelligent analysis as fallback instead of generic response
                        fullResponse = intelligentAnalysis.summary || generateFallbackResponse(userMessage, chatContext);
                        updateStreamingMessage(streamingMessage, fullResponse, true);
                        success = true;
                    }
                }
                
                if (success && fullResponse) {
                    // Add to conversation history
                    conversationHistory.push({ role: 'user', content: userMessage });
                    conversationHistory.push({ role: 'assistant', content: fullResponse });
                    
                    // Keep conversation history reasonable size
                    if (conversationHistory.length > 20) {
                        conversationHistory = conversationHistory.slice(-20);
                    }
                    
                    console.log('‚úÖ Chat response completed');
                } else {
                    throw new Error('No response received from API');
                }
                
            } catch (error) {
                console.error('Chat error:', error);
                // Update streaming message with error
                if (streamingMessage) {
                    updateStreamingMessage(streamingMessage, `Sorry, I encountered an error: ${error.message}. Please try again.`, true);
                } else {
                    addMessageToChat('system', `Sorry, I encountered an error: ${error.message}. Please try again.`);
                }
            }
        }

        function createStreamingMessageContainer() {
            const chatMessages = document.getElementById('chatMessages');
            
            // Hide welcome screen
            const welcome = document.getElementById('chatWelcome');
            if (welcome) {
                welcome.style.display = 'none';
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message-modern assistant-message';
            
            messageDiv.innerHTML = `
                <div class="message-avatar-modern ai-avatar">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                        <line x1="9" y1="9" x2="9.01" y2="9"/>
                        <line x1="15" y1="9" x2="15.01" y2="9"/>
                    </svg>
                </div>
                <div class="message-content-modern streaming">
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageDiv;
        }

        function updateStreamingMessage(messageDiv, content, isComplete = false) {
            const contentElement = messageDiv.querySelector('.message-content-modern');
            
            if (contentElement) {
                // Apply professional formatting first
                let formattedContent = formatAIResponse(content);
                
                // Apply enhanced response formatting to make IRR references and values clickable
                if (window.enhancedResponseFormatter && isComplete) {
                    formattedContent = window.enhancedResponseFormatter.formatResponse(formattedContent);
                }
                
                contentElement.innerHTML = formattedContent;
                
                if (isComplete) {
                    contentElement.classList.remove('streaming');
                } else {
                    contentElement.classList.add('streaming');
                }
            }
            
            // Scroll to bottom
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function formatAIResponse(content) {
            if (!content || typeof content !== 'string') return content;
            
            // Try to parse as JSON first (for structured responses)
            try {
                const jsonData = JSON.parse(content);
                if (jsonData.summary || jsonData.key_metrics || jsonData.answer) {
                    return renderStructuredResponse(jsonData);
                }
            } catch (e) {
                // Not JSON, continue with text formatting
            }
            
            // Apply text formatting for regular responses
            let formatted = content
                // Remove LaTeX completely
                .replace(/\\text\{([^}]+)\}/g, '$1')
                .replace(/\\times/g, '√ó')
                .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '$1/$2')
                .replace(/\\\[[\s\S]*?\\\]/g, '')
                .replace(/\\\([\s\S]*?\\\)/g, '')
                
                // Convert markdown headers to clean HTML
                .replace(/### ([^#\n]+)/g, '<div class="response-section-header">$1</div>')
                .replace(/## ([^#\n]+)/g, '<div class="response-section-header">$1</div>')
                
                // Convert **bold** to highlighted spans
                .replace(/\*\*([^*]+)\*\*/g, '<span class="value-highlight">$1</span>')
                
                // Make Excel cell references clickable
                .replace(/\b([A-Z]+![A-Z]+\d+(?::[A-Z]+\d+)?)\b/g, 
                    '<span class="cell-reference-clickable" onclick="navigateToExcelCell(\'$1\')">$1</span>')
                
                // Highlight financial values
                .replace(/\$[\d,]+(?:\.\d{2})?(?:\s*(?:million|Million|M|K|thousand))?/g, 
                    '<span class="money-highlight">$&</span>')
                .replace(/\b\d+(?:\.\d+)?%/g, '<span class="percentage-highlight">$&</span>')
                
                // Convert numbered lists
                .replace(/^\d+\.\s+(.+)$/gm, '<div class="list-item-numbered">$1</div>')
                
                // Convert bullet points
                .replace(/^[-‚Ä¢*]\s+(.+)$/gm, '<div class="list-item-bullet">$1</div>')
                
                // Convert line breaks
                .replace(/\n\n+/g, '<br><br>')
                .replace(/\n/g, '<br>')
                .trim();
            
            return formatted;
        }
        
        function renderStructuredResponse(data) {
            let html = '<div class="structured-response">';
            
            // Summary
            if (data.summary) {
                html += `<div class="response-summary">${data.summary}</div>`;
            }
            
            // Key Metrics
            if (data.key_metrics && Array.isArray(data.key_metrics)) {
                html += '<div class="metrics-section">';
                html += '<div class="response-section-header">Key Metrics</div>';
                html += '<div class="metrics-grid">';
                
                data.key_metrics.forEach(metric => {
                    html += `
                        <div class="metric-card" onclick="navigateToExcelCell('${metric.location || ''}')">
                            <div class="metric-label">${metric.metric || metric.label}</div>
                            <div class="metric-value">${metric.value}</div>
                            ${metric.location ? `<div class="metric-location">${metric.location}</div>` : ''}
                            ${metric.interpretation ? `<div class="metric-interpretation">${metric.interpretation}</div>` : ''}
                            ${metric.context ? `<div class="metric-context">${metric.context}</div>` : ''}
                        </div>
                    `;
                });
                
                html += '</div></div>';
            }
            
            // Insights
            if (data.insights && Array.isArray(data.insights)) {
                html += '<div class="insights-section">';
                html += '<div class="response-section-header">Key Insights</div>';
                
                data.insights.forEach(insight => {
                    html += `
                        <div class="insight-item ${insight.type || 'neutral'}">
                            <div class="insight-title">${insight.title}</div>
                            <div class="insight-content">${insight.content}</div>
                            ${insight.impact ? `<div class="insight-impact ${insight.impact}">${insight.impact} impact</div>` : ''}
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            // Recommendations
            if (data.recommendations && Array.isArray(data.recommendations)) {
                html += '<div class="recommendations-section">';
                html += '<div class="response-section-header">Recommendations</div>';
                
                data.recommendations.forEach(rec => {
                    html += `
                        <div class="recommendation-item ${rec.priority}">
                            <div class="rec-priority ${rec.priority}">${rec.priority} priority</div>
                            <div class="rec-action">${rec.action}</div>
                            <div class="rec-rationale">${rec.rationale}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            // General answer
            if (data.answer) {
                html += `<div class="response-answer">${formatAIResponse(data.answer)}</div>`;
            }
            
            html += '</div>';
            return html;
        }

        async function sendStreamingRequest(prompt, messageContainer) {
            // This function is deprecated - streaming is now handled directly in sendMessageToOpenAI
            // Throwing error to trigger fallback to direct API call
            throw new Error('Streaming not implemented - use direct API call');
        }

        async function simulateTypingEffect(messageContainer, fullText) {
            const textElement = messageContainer.querySelector('.message-text');
            const typingIndicator = messageContainer.querySelector('.typing-indicator');
            
            if (!textElement) return;
            
            // Clear any existing text
            textElement.textContent = '';
            
            // Type out the message character by character
            for (let i = 0; i < fullText.length; i++) {
                textElement.textContent += fullText[i];
                
                // Scroll to bottom
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Add small delay between characters (faster for spaces and punctuation)
                const char = fullText[i];
                const delay = char === ' ' ? 5 : char.match(/[.!?]/) ? 100 : 20;
                
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            // Hide typing indicator when done
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
            
            messageContainer.classList.remove('streaming');
        }

        function generateFallbackResponse(userMessage, context) {
            const query = userMessage.toLowerCase();
            
            // Check if we have Excel context
            if (context && !context.error && context.sheets) {
                const availableSheets = Object.keys(context.sheets).join(', ');
                let response = `I can see you're asking about "${userMessage}" in your Excel model.\n\n`;
                
                response += `üìä **Current Excel Context:**\n`;
                response += `- Workbook: ${context.workbook}\n`;
                response += `- Active Sheet: ${context.activeSheet}\n`;
                response += `- Available Sheets: ${availableSheets}\n\n`;
                
                if (query.includes('moic')) {
                    response += `**About MOIC (Multiple on Invested Capital):**\n`;
                    response += `MOIC could be low due to several factors:\n`;
                    response += `1. **Low Exit Value**: The terminal valuation may be conservative\n`;
                    response += `2. **High Initial Investment**: Large upfront capital requirement\n`;
                    response += `3. **Poor Operational Performance**: Lower than expected cash flows\n`;
                    response += `4. **Market Conditions**: Industry-specific challenges\n\n`;
                    response += `üìç **To help you better, please:**\n`;
                    response += `- Check your exit assumptions and terminal multiples\n`;
                    response += `- Review your revenue and EBITDA projections\n`;
                    response += `- Verify your initial equity investment calculation\n\n`;
                } else if (query.includes('irr')) {
                    response += `**About IRR (Internal Rate of Return):**\n`;
                    response += `IRR issues typically stem from:\n`;
                    response += `1. **Cash Flow Timing**: Delayed positive cash flows\n`;
                    response += `2. **Exit Timing**: Longer holding period\n`;
                    response += `3. **Operating Performance**: Lower margins or growth\n\n`;
                } else {
                    response += `**I can help you analyze:**\n`;
                    response += `- Financial metrics and calculations\n`;
                    response += `- Model structure and formulas\n`;
                    response += `- Assumptions and sensitivities\n\n`;
                }
                
                response += `‚ö†Ô∏è **Note**: The AI service is currently unavailable, so I'm providing this analysis based on the Excel data I can see. For detailed analysis of your specific calculations, please check your API configuration in Settings.`;
                
                return response;
            } else {
                return `I received your question "${userMessage}" but I'm currently unable to access the AI service or read your Excel model data.\n\n` +
                       `üîß **Troubleshooting:**\n` +
                       `1. Check your OpenAI API key in Settings\n` +
                       `2. Ensure you're working in Excel (not just the browser)\n` +
                       `3. Verify the add-in has proper permissions\n\n` +
                       `üí° **In the meantime**, I'd be happy to help with general M&A modeling questions if you describe your specific situation or numbers.`;
            }
        }

        function addMessageToChat(type, content) {
            const chatMessages = document.getElementById('chatMessages');
            
            // Hide welcome screen when first message is added
            const welcome = document.getElementById('chatWelcome');
            if (welcome) {
                welcome.style.display = 'none';
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message-modern ${type}-message`;
            
            let avatar, avatarClass;
            
            if (type === 'user') {
                avatar = 'U';
                avatarClass = 'user-avatar';
            } else if (type === 'assistant') {
                avatar = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                    <line x1="9" y1="9" x2="9.01" y2="9"/>
                    <line x1="15" y1="9" x2="15.01" y2="9"/>
                </svg>`;
                avatarClass = 'ai-avatar';
            } else {
                avatar = '!';
                avatarClass = 'system-avatar';
            }
            
            messageDiv.innerHTML = `
                <div class="message-avatar-modern ${avatarClass}">
                    ${avatar}
                </div>
                <div class="message-content-modern">
                    ${content}
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            
            // Scroll to bottom with smooth animation
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageDiv;
        }

        function addLoadingMessageToChat(text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message loading-message';
            
            messageDiv.innerHTML = `
                <div class="message-avatar arcadeus-avatar"><img src="assets/Arcadeus.svg" alt="Arcadeus" class="avatar-logo"></div>
                <div class="loading-message-content">
                    <div class="message-text" id="loadingText">${text}</div>
                    <div class="loading-progress">
                        <div class="progress-bar-container">
                            <div class="progress-bar-fill" id="progressBarFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="progressText">0%</div>
                    </div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            
            // Scroll to bottom with extra space
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageDiv;
        }

        function updateLoadingMessage(messageElement, text, progress, isComplete = false) {
            if (!messageElement) return;
            
            const textElement = messageElement.querySelector('#loadingText');
            const progressFill = messageElement.querySelector('#progressBarFill');
            const progressText = messageElement.querySelector('#progressText');
            
            if (textElement) textElement.textContent = text;
            if (progressFill) progressFill.style.width = `${progress}%`;
            if (progressText) progressText.textContent = `${Math.round(progress)}%`;
            
            if (isComplete) {
                setTimeout(() => {
                    messageElement.classList.add('completed');
                }, 300);
            }
        }

        function updateSystemMessage(messageElement, newContent) {
            if (messageElement) {
                const textElement = messageElement.querySelector('.message-text');
                if (textElement) {
                    textElement.textContent = newContent;
                }
            }
        }

        // Input tab functionality
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM loaded - assumption tabs will be initialized by main app class');

            const inputTabs = document.querySelectorAll('.input-tab');
            inputTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    inputTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            // Initialize Enhanced Chat System
            initializeEnhancedChatSystem();

            // Menu dropdown functionality
            const menuIcon = document.getElementById('menuIcon');
            const menuDropdown = document.getElementById('menuDropdown');
            
            if (menuIcon && menuDropdown) {
                menuIcon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    menuDropdown.classList.toggle('show');
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', function() {
                    menuDropdown.classList.remove('show');
                });

                menuDropdown.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }

            // Sign out functionality
            const signOutButton = document.getElementById('signOutButton');
            if (signOutButton) {
                signOutButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Clear localStorage
                    localStorage.removeItem('arcadeusUser');
                    localStorage.removeItem('arcadeusUserProfile');
                    localStorage.removeItem('arcadeusOnboarding');
                    
                    // Redirect to login
                    window.location.href = 'login.html';
                });
            }

            // Upgrade button functionality
            const upgradeButton = document.getElementById('upgradeButton');
            if (upgradeButton) {
                upgradeButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    window.open('https://arcadeus.ai', '_blank');
                });
            }

            // Assumption tabs will be initialized by main app class
            
            // Initialize progress tracking
            initializeProgressTracking();
            
            // Re-initialize tabs if they get lost (safeguard)
            // This observer will detect if the tabs container is modified
            const tabsObserver = new MutationObserver(function(mutations) {
                const tabsContainer = document.querySelector('.assumptions-tabs');
                if (tabsContainer && !tabsContainer.hasAttribute('data-initialized')) {
                    console.log('Re-initializing tabs due to DOM change');
                    initializeAssumptionTabs();
                    tabsContainer.setAttribute('data-initialized', 'true');
                }
            });
            
            // Start observing the assumptions page for changes
            const assumptionsPage = document.getElementById('assumptionsPage');
            if (assumptionsPage) {
                tabsObserver.observe(assumptionsPage, {
                    childList: true,
                    subtree: true
                });
            }
        });

        function handleTabClick(e) {
            try {
                // Check if clicked element is a tab button
                const tab = e.target.closest('.assumption-tab');
                if (!tab) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                const targetId = tab.getAttribute('data-tab');
                console.log('Tab clicked:', targetId);
                
                // Ensure tabs container remains visible
                const tabsContainer = document.querySelector('.assumptions-tabs');
                if (tabsContainer) {
                    tabsContainer.style.display = 'flex';
                    tabsContainer.style.visibility = 'visible';
                    tabsContainer.style.opacity = '1';
                }
                
                // Get fresh references to all tabs and panels
                const allTabs = document.querySelectorAll('.assumption-tab');
                const allPanels = document.querySelectorAll('.tab-panel');
                
                console.log(`Found ${allTabs.length} tabs and ${allPanels.length} panels`);
                
                // Remove active class from all tabs and panels
                allTabs.forEach(t => t.classList.remove('active'));
                allPanels.forEach(p => p.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding panel
                tab.classList.add('active');
                const targetPanel = document.getElementById(targetId);
                if (targetPanel) {
                    targetPanel.classList.add('active');
                    console.log('Panel activated:', targetId);
                } else {
                    console.error('Target panel not found:', targetId);
                }
                
                // Update progress tracking
                if (typeof updateProgress === 'function') {
                    updateProgress();
                }
                
                console.log('Tab click handled successfully');
            } catch (error) {
                console.error('Error in handleTabClick:', error);
                
                // Force tabs container to remain visible on error
                const tabsContainer = document.querySelector('.assumptions-tabs');
                if (tabsContainer) {
                    tabsContainer.style.display = 'flex';
                    tabsContainer.style.visibility = 'visible';
                    tabsContainer.style.opacity = '1';
                }
            }
        }

        function initializeAssumptionTabs() {
            try {
                console.log('üîß Initializing assumption tabs...');
                
                // Use event delegation on the parent container instead of individual tabs
                const tabsContainer = document.querySelector('.assumptions-tabs');
                
                if (!tabsContainer) {
                    console.error('‚ùå Tabs container not found');
                    return;
                }
                
                // Force visibility
                tabsContainer.style.display = 'flex';
                tabsContainer.style.visibility = 'visible';
                tabsContainer.style.opacity = '1';
                
                // Remove any existing listeners
                tabsContainer.removeEventListener('click', handleTabClick);
                
                // Add the event listener to the container
                tabsContainer.addEventListener('click', handleTabClick);
                
                // Mark as initialized
                tabsContainer.setAttribute('data-initialized', 'true');
                
                console.log('‚úÖ Tab event listener attached to container');
                
                // Verify all tab buttons exist
                const tabs = tabsContainer.querySelectorAll('.assumption-tab');
                console.log(`‚úÖ Found ${tabs.length} tab buttons:`, Array.from(tabs).map(t => t.getAttribute('data-tab')));
                
            } catch (error) {
                console.error('‚ùå Error initializing assumption tabs:', error);
            }
        }
        
        // Make function globally available
        window.initializeAssumptionTabs = initializeAssumptionTabs;
        
        // Add a mutation observer to watch for disappearing tabs
        function setupTabsWatcher() {
            const tabsContainer = document.querySelector('.assumptions-tabs');
            if (!tabsContainer) return;
            
            // Create observer
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && 
                        (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
                        
                        const container = mutation.target;
                        const isHidden = container.style.display === 'none' || 
                                       container.style.visibility === 'hidden' || 
                                       container.style.opacity === '0' ||
                                       container.classList.contains('hidden');
                        
                        if (isHidden) {
                            console.warn('‚ö†Ô∏è Tabs container was hidden! Restoring visibility...');
                            container.style.display = 'flex';
                            container.style.visibility = 'visible'; 
                            container.style.opacity = '1';
                            container.classList.remove('hidden');
                        }
                    }
                });
            });
            
            // Start observing
            observer.observe(tabsContainer, {
                attributes: true,
                attributeFilter: ['style', 'class']
            });
            
            console.log('‚úÖ Tabs visibility watcher established');
        }
        
        // Setup watcher after DOM is ready
        setTimeout(setupTabsWatcher, 1000);
        
        // Additional aggressive protection - check every 2 seconds
        setInterval(() => {
            const tabsContainer = document.querySelector('.assumptions-tabs');
            if (tabsContainer) {
                const isVisible = tabsContainer.offsetHeight > 0 && 
                                 tabsContainer.offsetWidth > 0 && 
                                 window.getComputedStyle(tabsContainer).display !== 'none' &&
                                 window.getComputedStyle(tabsContainer).visibility !== 'hidden';
                
                if (!isVisible) {
                    console.warn('üö® Tabs became invisible! Forcing visibility...');
                    tabsContainer.style.display = 'flex';
                    tabsContainer.style.visibility = 'visible';
                    tabsContainer.style.opacity = '1';
                    tabsContainer.style.position = 'relative';
                    tabsContainer.style.zIndex = '10';
                    tabsContainer.style.minHeight = '48px';
                    
                    // Also ensure parent container is visible
                    const assumptionsPage = document.getElementById('assumptionsPage');
                    if (assumptionsPage && assumptionsPage.style.display === 'block') {
                        console.log('‚úÖ Tabs visibility restored');
                    }
                }
            }
        }, 2000);

        function initializeProgressTracking() {
            const sections = [
                'highLevelParameters',
                'dealAssumptions', 
                'revenueItems',
                'operatingExpenses',
                'capEx',
                'exitAssumptions',
                'debtModel'
            ];
            
            // Add change listeners to all form inputs
            sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const inputs = section.querySelectorAll('input, select, textarea');
                    inputs.forEach(input => {
                        input.addEventListener('input', updateProgress);
                        input.addEventListener('change', updateProgress);
                    });
                }
            });
            
            // Set up observer for dynamically added items
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) { // Element node
                            // Check if the added node is a revenue/cost item
                            if (node.classList && (node.classList.contains('revenue-item') || 
                                node.classList.contains('cost-item'))) {
                                const inputs = node.querySelectorAll('input, select, textarea');
                                inputs.forEach(input => {
                                    input.addEventListener('input', updateProgress);
                                    input.addEventListener('change', updateProgress);
                                });
                                updateProgress(); // Update immediately when item is added
                            }
                        }
                    });
                });
            });
            
            // Start observing for dynamic content changes
            sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    observer.observe(section, { childList: true, subtree: true });
                }
            });
            
            // Initial progress update
            updateProgress();
        }
        
        // Function to generate model from progress button
        async function generateFullModelFromProgress() {
            // Wait for MAModelingAddin to be available
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max wait time
            
            while ((!window.maModelingAddin || !window.maModelingAddin.generateFullModelWithProgress) && attempts < maxAttempts) {
                console.log(`Waiting for MAModelingAddin to initialize... (attempt ${attempts + 1}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!window.maModelingAddin || !window.maModelingAddin.generateFullModelWithProgress) {
                console.error('Taskpane app not available - maModelingAddin instance not found after waiting');
                console.log('Available window properties:', Object.keys(window));
                console.log('maModelingAddin:', window.maModelingAddin);
                
                // Show user-friendly error message
                const progressBarWrapper = document.querySelector('.progress-bar-wrapper');
                if (progressBarWrapper) {
                    progressBarWrapper.innerHTML = `
                        <div style="text-align: center; color: #dc3545; padding: 20px;">
                            <p>‚ö†Ô∏è Add-in not fully loaded. Please refresh the page and try again.</p>
                            <button onclick="window.location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #217346; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Refresh Page
                            </button>
                        </div>
                    `;
                }
                return;
            }
            
            const progressContainer = document.querySelector('.progress-container');
            const progressBarWrapper = document.querySelector('.progress-bar-wrapper');
            
            // Replace button with progress indicator
            if (progressBarWrapper) {
                progressBarWrapper.innerHTML = `
                    <div class="generation-progress-wrapper">
                        <div class="generation-progress-text">Generating model pages...</div>
                        <div class="generation-progress-bar">
                            <div class="generation-progress-fill" id="generationProgressFill"></div>
                        </div>
                        <div class="generation-status" id="generationStatus">Preparing to generate...</div>
                    </div>
                `;
            }
            
            try {
                await window.maModelingAddin.generateFullModelWithProgress();
                
                // Show success and change to refresh model
                if (progressBarWrapper) {
                    progressBarWrapper.innerHTML = `
                        <button class="progress-generate-button refresh-button" id="refreshModelBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
                                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
                            </svg>
                            Refresh Model
                        </button>
                    `;
                    
                    // Add click handler for refresh
                    const refreshBtn = document.getElementById('refreshModelBtn');
                    if (refreshBtn) {
                        refreshBtn.addEventListener('click', () => {
                            generateFullModelFromProgress();
                        });
                    }
                }
            } catch (error) {
                console.error('Model generation failed:', error);
                
                // Reset to generate button on error
                if (progressBarWrapper) {
                    progressBarWrapper.innerHTML = `
                        <button class="progress-generate-button" id="progressGenerateBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="3" y1="9" x2="21" y2="9"></line>
                                <line x1="9" y1="21" x2="9" y2="9"></line>
                            </svg>
                            Generate Full Model
                        </button>
                    `;
                    
                    const progressGenerateBtn = document.getElementById('progressGenerateBtn');
                    if (progressGenerateBtn) {
                        progressGenerateBtn.addEventListener('click', () => {
                            generateFullModelFromProgress();
                        });
                    }
                }
            }
        }
        
        function updateProgress() {
            console.log('üîÑ Updating progress...');
            const sections = [
                { id: 'highLevelParameters', requiredFields: ['currency', 'projectStartDate', 'modelPeriods', 'projectEndDate'] },
                { id: 'dealAssumptions', requiredFields: ['dealName', 'dealValue', 'transactionFee', 'dealLTV'] },
                { id: 'revenueItems', requiredFields: [] }, // Will check for revenue items
                { id: 'operatingExpenses', requiredFields: [] }, // Will check for expense items  
                { id: 'capEx', requiredFields: [] }, // Will check for capex items
                { id: 'exitAssumptions', requiredFields: ['disposalCost', 'terminalCapRate'] },
                { id: 'debtModel', requiredFields: [] } // Special handling for debt model
            ];
            
            let completedSections = 0;
            
            sections.forEach(section => {
                let sectionComplete = true;
                
                if (section.requiredFields.length > 0) {
                    // Check required fields
                    section.requiredFields.forEach(fieldId => {
                        const field = document.getElementById(fieldId);
                        if (!field || !field.value.trim()) {
                            sectionComplete = false;
                        }
                    });
                } else if (section.id === 'debtModel') {
                    // Special handling for debt model - check if LTV enables debt or if settings are filled
                    const ltvField = document.getElementById('dealLTV');
                    const ltv = ltvField ? parseFloat(ltvField.value) || 0 : 0;
                    
                    if (ltv > 0) {
                        // If LTV > 0, check if debt settings are filled
                        const loanFees = document.getElementById('loanIssuanceFees');
                        const interestRate = document.getElementById('fixedRate');
                        if (!loanFees?.value || !interestRate?.value) {
                            sectionComplete = false;
                        }
                    }
                    // If LTV = 0, debt section is considered complete (no debt needed)
                } else {
                    // For dynamic sections (revenue, expenses, capex), check if items exist and have values
                    const sectionElement = document.getElementById(section.id);
                    if (sectionElement) {
                        const items = sectionElement.querySelectorAll('.revenue-item, .cost-item');
                        if (items.length === 0) {
                            sectionComplete = false;
                        } else {
                            // Check if at least one item has both name and value filled
                            let hasCompleteItem = false;
                            items.forEach(item => {
                                const nameInput = item.querySelector('input[id*="Name"]');
                                const valueInput = item.querySelector('input[id*="Value"]');
                                console.log(`üîç Checking item:`, {
                                    name: nameInput?.value,
                                    value: valueInput?.value,
                                    nameId: nameInput?.id,
                                    valueId: valueInput?.id
                                });
                                if (nameInput?.value.trim() && valueInput?.value.trim()) {
                                    hasCompleteItem = true;
                                }
                            });
                            if (!hasCompleteItem) {
                                sectionComplete = false;
                                console.log(`‚ùå ${section.id}: No complete items found`);
                            } else {
                                console.log(`‚úÖ ${section.id}: Has complete items`);
                            }
                        }
                    }
                }
                
                // Update tab visual state based on completion
                const tabElement = document.querySelector(`.assumption-tab[data-tab="${section.id}"]`);
                if (tabElement) {
                    if (sectionComplete) {
                        tabElement.classList.add('completed');
                    } else {
                        tabElement.classList.remove('completed');
                    }
                }
                
                if (sectionComplete) {
                    completedSections++;
                    console.log(`‚úÖ Section ${section.id} completed`);
                } else {
                    console.log(`‚ùå Section ${section.id} incomplete`);
                }
            });
            
            // Update progress bar or show generate button
            const progressContainer = document.querySelector('.progress-container');
            const progressBarWrapper = document.querySelector('.progress-bar-wrapper');
            
            if (completedSections === sections.length) {
                // Replace progress bar with generate button
                if (progressBarWrapper && !progressContainer.querySelector('.progress-generate-button')) {
                    progressBarWrapper.innerHTML = `
                        <button class="progress-generate-button" id="progressGenerateBtn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="3" y1="9" x2="21" y2="9"></line>
                                <line x1="9" y1="21" x2="9" y2="9"></line>
                            </svg>
                            Generate Full Model
                        </button>
                    `;
                    
                    // Add click handler to the new button
                    const progressGenerateBtn = document.getElementById('progressGenerateBtn');
                    if (progressGenerateBtn) {
                        progressGenerateBtn.addEventListener('click', () => {
                            generateFullModelFromProgress();
                        });
                    }
                }
            } else {
                // Show progress bar
                if (progressBarWrapper && !progressBarWrapper.querySelector('.progress-bar')) {
                    progressBarWrapper.innerHTML = `
                        <div class="progress-bar" id="assumptionsProgress">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-text">
                            <span id="progressText">0 of 7 sections completed</span>
                        </div>
                    `;
                }
                
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const progressPercentage = (completedSections / sections.length) * 100;
                
                if (progressFill) {
                    progressFill.style.width = progressPercentage + '%';
                }
                
                if (progressText) {
                    progressText.textContent = `${completedSections} of ${sections.length} sections completed`;
                }
            }
            
            console.log(`üìä Progress: ${completedSections}/${sections.length} sections completed`);
        }

        async function autoFillWithAI() {
            console.log('ü§ñ AutoFill with AI function called - using new enhanced prompt with realistic values');
            console.log('üî• AI AUTOFILL FUNCTION STARTED - NO HARDCODED VALUES');
            console.log('‚ö†Ô∏è If you see test data being filled, the hardcoded function is still running');
            
            // Close the dropdown
            const menuDropdown = document.getElementById('menuDropdown');
            if (menuDropdown) {
                menuDropdown.classList.remove('show');
            }
            
            // Show loading state
            const loadingToast = showLoadingToast('Generating M&A model data with AI...');
            
            try {
                // Call OpenAI to generate comprehensive M&A data
                console.log('ü§ñ Calling generateAIData()...');
                const aiData = await generateAIData();
                console.log('‚úÖ generateAIData() returned:', aiData);
                console.log('üîç AI Data type:', typeof aiData);
                
                if (!aiData) {
                    console.error('‚ùå generateAIData() returned null/undefined');
                    showErrorToast('AI failed to generate data');
                    return;
                }
                
                // Fill all sections with the generated data
                console.log('üìù About to call fillAllSections with AI data...');
                await fillAllSections(aiData);
                
                // Ensure debt model section is visible if it was filled
                ensureDebtModelSectionVisible();
                
                // Update progress after filling
                if (typeof updateProgress === 'function') {
                    updateProgress();
                }
                
                hideLoadingToast(loadingToast);
                console.log('‚úÖ Auto-fill completed successfully');
                
            } catch (error) {
                console.error('AI Auto-fill error:', error);
                hideLoadingToast(loadingToast);
                showErrorToast('Failed to generate AI data. Please try again.');
            }
        }

        async function generateAIData() {
            console.log('üéØ generateAIData called - using enhanced institutional-grade prompt');
            const prompt = `Generate realistic M&A transaction data for a REAL ESTATE private equity deal with institutional-grade valuations. This should reflect actual real estate deal sizes and financial metrics from the market. Return valid JSON only with this structure:

{
  "highLevelParameters": {
    "currency": "USD",
    "projectStartDate": "2024-01-01",
    "projectEndDate": "2029-12-31",
    "modelPeriods": "yearly"
  },
  "dealAssumptions": {
    "dealName": "realistic real estate property name (e.g., Manhattan Office Tower, Sunbelt Logistics Center, Premier Retail Plaza, etc.)",
    "dealValue": "number between 75000000-500000000 (EXACT NUMBERS: 75 million to 500 million USD)",
    "transactionFee": "number between 1.5-2.8",
    "dealLTV": "number between 65-80"
  },
  "revenueItems": [
    {
      "name": "Real estate revenue stream (e.g., Base Rent, Parking Revenue, Tenant Reimbursements, Storage Income)",
      "value": "EXACT NUMBERS: between 3000000-25000000 (3 million to 25 million USD)",
      "growthRate": "number between 2-8 (realistic real estate growth rates)"
    }
  ],
  "operatingExpenses": [
    {
      "name": "Real estate operating expense (e.g., Property Management, Utilities, Maintenance & Repairs, Insurance, Property Taxes)",
      "value": "EXACT NUMBERS: between 500000-8000000 (500K to 8 million USD)",
      "growthRate": "number between 2-6"
    }
  ],
  "capEx": [
    {
      "name": "Real estate capital expenditure (e.g., Tenant Improvements, HVAC Upgrades, Roof Replacement, Elevator Modernization, Parking Lot Resurfacing)",
      "value": "EXACT NUMBERS: between 1000000-12000000 (1 million to 12 million USD)",
      "growthRate": "number between 1-5"
    }
  ],
  "exitAssumptions": {
    "disposalCost": "number between 2.0-3.5",
    "terminalCapRate": "number between 4.5-7.5"
  },
  "debtModel": {
    "loanIssuanceFees": "number between 0.75-1.5",
    "interestRateType": "fixed",
    "fixedRate": "number between 4.5-7.5",
    "wacc": "number between 6.5-10.5"
  }
}

CRITICAL REQUIREMENTS:
1. Generate 1-4 REAL ESTATE revenue items (varying each time) with realistic names like:
   - Base Rent, Parking Revenue, Storage Income, Tenant Reimbursements, Signage Revenue, Event Space Rental, etc.
2. Generate 1-4 REAL ESTATE operating expense items (varying each time) covering realistic costs like:
   - Property Management, Utilities, Maintenance & Repairs, Insurance, Property Taxes, Security, Landscaping, etc.
3. Generate 1-4 REAL ESTATE capex items (varying each time) with realistic property investments like:
   - Tenant Improvements, HVAC Upgrades, Roof Replacement, Elevator Modernization, Parking Improvements, etc.
4. ALL NUMBERS MUST BE EXACT NUMERIC VALUES (no text like "M" or "million"):
   - Deal values: 75000000 to 500000000 (75-500 million)
   - Revenue items: 3000000 to 25000000 each (3-25 million each)
   - Operating expenses: 500000 to 8000000 each (500K-8 million each)
   - CapEx items: 1000000 to 12000000 each (1-12 million each)
5. Revenue items should total 8000000-60000000 annually (8-60M total)
6. Operating expenses should be 25-45% of revenues (realistic NOI margins for real estate)
7. CapEx should be 8-15% of revenues annually (typical for real estate)
8. Use real property terminology and realistic property names
9. Include real estate appropriate WACC (6.5-10.5 range)
10. Include realistic real estate cap rates (4.5-7.5%)
11. RETURN ONLY NUMERIC VALUES - NO CURRENCY SYMBOLS OR TEXT
12. Vary the NUMBER of items each time (1-4 for each category) - don't always generate the same quantity

Generate a realistic real estate property (office, retail, industrial, mixed-use) with market-appropriate financial metrics.`;

            // Use the same Netlify Functions endpoint as existing generate model functionality
            const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const apiEndpoint = isLocal ? 'http://localhost:8888/.netlify/functions/chat' : '/.netlify/functions/chat';
            
            const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: prompt,
                    autoFillMode: true,
                    batchType: 'autofill_data_generation',
                    systemPrompt: 'You are a financial modeling expert. Generate realistic M&A deal data. Always return valid JSON only.',
                    temperature: 0.8,
                    maxTokens: 1500
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error Response:', errorText);
                throw new Error(`API error: ${response.status} - ${errorText}`);
            }

            const result = await response.json();
            console.log('AutoFill API Response:', result);
            
            // Handle Netlify Functions response format
            let content;
            if (result.content) {
                // Netlify Functions format from chat.js
                content = result.content;
            } else if (result.response) {
                // Alternative chat response format
                content = result.response;
            } else if (result.choices && result.choices[0]) {
                // OpenAI direct response format (fallback)
                content = result.choices[0].message.content.trim();
            } else {
                console.error('Unexpected API response structure:', result);
                throw new Error('Unexpected API response format');
            }
            
            // Parse JSON response
            console.log('Raw AI Content:', content);
            
            let jsonStart = content.indexOf('{');
            let jsonEnd = content.lastIndexOf('}') + 1;
            
            if (jsonStart === -1 || jsonEnd === 0) {
                console.error('No JSON found in response:', content);
                throw new Error('AI response does not contain valid JSON');
            }
            
            const jsonStr = content.substring(jsonStart, jsonEnd);
            console.log('Extracted JSON:', jsonStr);
            
            try {
                return JSON.parse(jsonStr);
            } catch (parseError) {
                console.error('JSON Parse Error:', parseError);
                console.error('Failed to parse:', jsonStr);
                throw new Error(`Failed to parse AI response as JSON: ${parseError.message}`);
            }
        }

        function ensureDebtModelSectionVisible() {
            console.log('üè¶ Ensuring debt model section is visible...');
            
            // Find the debt model section and ensure it's expanded
            const debtModelSection = document.getElementById('debtModel');
            if (debtModelSection) {
                // Remove collapsed state if present
                debtModelSection.classList.remove('collapsed');
                
                // Make sure the tab panel is visible
                debtModelSection.style.display = 'block';
                
                // Find and activate the debt model tab button
                const debtModelTab = document.querySelector('button[data-tab="debtModel"]');
                if (debtModelTab) {
                    debtModelTab.classList.add('active');
                    console.log('üìã Debt model tab activated');
                }
                
                // Find the minimize button and ensure it shows correct state
                const minimizeBtn = debtModelSection.querySelector('.minimize-btn');
                if (minimizeBtn) {
                    minimizeBtn.innerHTML = '‚àí'; // Show minimize symbol
                }
                
                console.log('üè¶ Debt model section is now visible and accessible');
            } else {
                console.error('‚ùå Debt model section not found');
            }
        }

        async function fillAllSections(data) {
            console.log('üîß fillAllSections() called with data:', data);
            console.log('üìä Data type:', typeof data);
            console.log('üìä Data keys:', data ? Object.keys(data) : 'null');
            
            if (!data) {
                console.error('‚ùå No data provided to fillAllSections');
                return;
            }
            
            // Fill Deal Profile
            console.log('üìù Filling Deal Profile...');
            document.getElementById('currency').value = data.highLevelParameters.currency;
            document.getElementById('projectStartDate').value = data.highLevelParameters.projectStartDate;
            document.getElementById('projectEndDate').value = data.highLevelParameters.projectEndDate;
            document.getElementById('modelPeriods').value = data.highLevelParameters.modelPeriods;
            
            // Fill Deal Assumptions
            document.getElementById('dealName').value = data.dealAssumptions.dealName;
            document.getElementById('dealValue').value = data.dealAssumptions.dealValue;
            document.getElementById('transactionFee').value = data.dealAssumptions.transactionFee;
            document.getElementById('dealLTV').value = data.dealAssumptions.dealLTV;
            
            // Fill Revenue Items
            await fillDynamicItems('revenue', data.revenueItems, 'revenueItemsContainer');
            
            // Fill Operating Expenses
            await fillDynamicItems('opEx', data.operatingExpenses, 'operatingExpensesContainer');
            
            // Fill CapEx
            await fillDynamicItems('capEx', data.capEx, 'capExContainer');
            
            // Fill Exit Assumptions
            document.getElementById('disposalCost').value = data.exitAssumptions.disposalCost;
            document.getElementById('terminalCapRate').value = data.exitAssumptions.terminalCapRate;
            
            // Fill Debt Model
            console.log('üè¶ Filling Debt Model section...', data.debtModel);
            if (data.debtModel) {
                if (data.debtModel.loanIssuanceFees) {
                    document.getElementById('loanIssuanceFees').value = data.debtModel.loanIssuanceFees;
                    console.log('‚úÖ Loan issuance fees filled:', data.debtModel.loanIssuanceFees);
                }
                
                if (data.debtModel.interestRateType) {
                    const interestRateTypeElement = document.querySelector('input[name="interestRateType"][value="' + data.debtModel.interestRateType + '"]');
                    if (interestRateTypeElement) {
                        interestRateTypeElement.checked = true;
                        console.log('‚úÖ Interest rate type set:', data.debtModel.interestRateType);
                    }
                }
                
                if (data.debtModel.fixedRate) {
                    document.getElementById('fixedRate').value = data.debtModel.fixedRate;
                    console.log('‚úÖ Fixed rate filled:', data.debtModel.fixedRate);
                }
                
                // Fill WACC (discountRate field in exit assumptions section)
                if (data.debtModel.wacc) {
                    const waccElement = document.getElementById('discountRate');
                    if (waccElement) {
                        console.log('‚úÖ Filling WACC/Discount Rate:', data.debtModel.wacc);
                        waccElement.value = data.debtModel.wacc;
                    } else {
                        console.error('‚ùå discountRate field not found');
                    }
                } else {
                    console.error('‚ùå WACC value missing from AI data');
                }
            } else {
                console.error('‚ùå Debt model data missing from AI response');
            }
        }

        async function fillDynamicItems(type, items, containerId) {
            console.log(`üîß fillDynamicItems called for ${type}, items:`, items, `containerId: ${containerId}`);
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`‚ùå Container not found: ${containerId}`);
                return;
            }
            
            if (!items || !Array.isArray(items)) {
                console.error(`‚ùå Items is not an array for ${type}:`, items);
                return;
            }
            
            console.log(`üìù Processing ${items.length} items for ${type}`);
            
            // Clear existing items except the first one
            const existingItems = container.querySelectorAll(`.${type === 'revenue' ? 'revenue' : 'cost'}-item`);
            for (let i = 1; i < existingItems.length; i++) {
                existingItems[i].remove();
            }
            
            // Fill items
            for (let i = 0; i < items.length; i++) {
                const itemNumber = i + 1;
                const item = items[i];
                
                // Add new item if needed
                if (i > 0) {
                    if (type === 'revenue') {
                        if (window.formHandler && window.formHandler.addRevenueItem) {
                            window.formHandler.addRevenueItem();
                        }
                    } else {
                        if (window.formHandler && window.formHandler.addCostItem) {
                            window.formHandler.addCostItem(type === 'opEx' ? 'operating' : 'capex');
                        }
                    }
                    
                    // Wait a bit for DOM to update
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Fill the item data
                const nameId = type === 'revenue' ? `revenueName_${itemNumber}` : 
                             type === 'opEx' ? `opExName_${itemNumber}` : `capExName_${itemNumber}`;
                const valueId = type === 'revenue' ? `revenueValue_${itemNumber}` : 
                              type === 'opEx' ? `opExValue_${itemNumber}` : `capExValue_${itemNumber}`;
                const growthId = type === 'revenue' ? `revenueGrowthRate_${itemNumber}` : 
                               type === 'opEx' ? `opExGrowthRate_${itemNumber}` : `capExGrowthRate_${itemNumber}`;
                
                const nameField = document.getElementById(nameId);
                const valueField = document.getElementById(valueId);
                const growthField = document.getElementById(growthId);
                
                if (nameField) nameField.value = item.name;
                if (valueField) valueField.value = item.value;
                if (growthField) growthField.value = item.growthRate;
            }
        }

        function getOpenAIKey() {
            // Try to get from environment variables or localStorage
            return localStorage.getItem('openai_api_key') || 
                   process?.env?.OPENAI_API_KEY || 
                   'sk-your-openai-key-here'; // Replace with actual key
        }

        // Toast notification functions
        function showLoadingToast(message) {
            const toast = document.createElement('div');
            toast.className = 'ai-toast loading';
            toast.innerHTML = `
                <div class="toast-content">
                    <img src="assets/Arcadeus.svg" alt="Loading" class="toast-spinner">
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 100);
            return toast;
        }

        function showSuccessToast(message) {
            const toast = document.createElement('div');
            toast.className = 'ai-toast success';
            toast.innerHTML = `
                <div class="toast-content">
                    <svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 11l3 3L22 4"></path>
                        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                    </svg>
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => hideLoadingToast(toast), 4000);
        }

        function showErrorToast(message) {
            const toast = document.createElement('div');
            toast.className = 'ai-toast error';
            toast.innerHTML = `
                <div class="toast-content">
                    <svg class="toast-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                    </svg>
                    <span>${message}</span>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => hideLoadingToast(toast), 5000);
        }

        function hideLoadingToast(toast) {
            if (toast && toast.parentNode) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }

        // ============================================
        // COMPREHENSIVE EXCEL + AI INTEGRATION
        // Following your 4-step integration guide
        // ============================================
        
        // STEP 1: Enhanced Excel Reading with Live Context
        async function handleUserQuery(userInput) {
            try {
                // Clear input and show user message
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.value = '';
                    chatInput.style.height = 'auto';
                }
                
                addMessageToChat('user', userInput);
                
                // Show loading state
                const loadingMessage = createStreamingMessageContainer();
                updateStreamingMessage(loadingMessage, "üìä Reading Excel data...", false);
                
                // Get comprehensive Excel context
                let excelContext = await getExcelContext();
                
                updateStreamingMessage(loadingMessage, "ü§ñ Analyzing with AI...", false);
                
                // Process with AI
                await processWithAI(userInput, excelContext, loadingMessage);
                
            } catch (error) {
                console.error('‚ùå Error in handleUserQuery:', error);
                addMessageToChat('assistant', `Sorry, I encountered an error: ${error.message}`);
            }
        }

        // Get comprehensive Excel context (selected range + workbook info)
        async function getExcelContext() {
            let context = {
                selectedRange: null,
                activeSheet: '',
                worksheetNames: [],
                error: null
            };
            
            await Excel.run(async (excelContext) => {
                try {
                    // Get selected range with all properties
                    const selectedRange = excelContext.workbook.getSelectedRange();
                    selectedRange.load(['values', 'formulas', 'address', 'rowCount', 'columnCount']);
                    
                    // Get active worksheet
                    const activeSheet = excelContext.workbook.worksheets.getActiveWorksheet();
                    activeSheet.load(['name']);
                    
                    // Get all worksheets
                    const worksheets = excelContext.workbook.worksheets;
                    worksheets.load(['name']);
                    
                    await excelContext.sync();
                    
                    context.selectedRange = {
                        address: selectedRange.address,
                        values: selectedRange.values,
                        formulas: selectedRange.formulas,
                        rowCount: selectedRange.rowCount,
                        columnCount: selectedRange.columnCount
                    };
                    context.activeSheet = activeSheet.name;
                    context.worksheetNames = worksheets.items.map(ws => ws.name);
                    
                    console.log('‚úÖ Excel context captured:', context);
                    
                } catch (rangeError) {
                    // Handle case where no range is selected
                    const activeSheet = excelContext.workbook.worksheets.getActiveWorksheet();
                    activeSheet.load(['name']);
                    const worksheets = excelContext.workbook.worksheets;
                    worksheets.load(['name']);
                    await excelContext.sync();
                    
                    context.activeSheet = activeSheet.name;
                    context.worksheetNames = worksheets.items.map(ws => ws.name);
                    context.error = 'No range selected';
                    
                    console.log('‚ö†Ô∏è No range selected, got worksheet info only');
                }
            });
            
            return context;
        }

        // STEP 2: AI Processing with Real Excel Searching
        async function processWithAI(userInput, excelContext, loadingMessage) {
            try {
                // First, search ALL sheets for relevant financial data
                updateStreamingMessage(loadingMessage, "üîç Searching all Excel sheets for financial data...", false);
                
                const comprehensiveData = await searchAllSheetsForFinancialData(userInput.toLowerCase());
                
                // Build context string for AI
                let contextString = `Active Sheet: ${excelContext.activeSheet}\n`;
                contextString += `Available Sheets: ${excelContext.worksheetNames.join(', ')}\n`;
                
                if (excelContext.selectedRange && !excelContext.error) {
                    contextString += `Selected Range: ${excelContext.selectedRange.address}\n`;
                    contextString += `Size: ${excelContext.selectedRange.rowCount}√ó${excelContext.selectedRange.columnCount}\n`;
                    
                    if (excelContext.selectedRange.values?.length > 0) {
                        contextString += `Values Sample: ${JSON.stringify(excelContext.selectedRange.values.slice(0, 5))}\n`;
                    }
                    if (excelContext.selectedRange.formulas?.length > 0) {
                        contextString += `Formulas Sample: ${JSON.stringify(excelContext.selectedRange.formulas.slice(0, 5))}\n`;
                    }
                }
                
                // Add comprehensive search results
                if (comprehensiveData.foundData.length > 0) {
                    contextString += `\nFOUND FINANCIAL DATA:\n`;
                    comprehensiveData.foundData.forEach(item => {
                        contextString += `- ${item.sheet}!${item.address}: "${item.label}" = ${item.value} ${item.formula ? `(Formula: ${item.formula})` : ''}\n`;
                    });
                } else {
                    contextString += `\nNote: No specific financial metrics found in available sheets\n`;
                }
                
                // Enhanced AI prompt with search results
                const aiPrompt = `You are an expert Excel and M&A financial analyst.

User Question: "${userInput}"

Excel Context & Search Results:
${contextString}

IMPORTANT: Based on the Excel data found above, provide specific analysis. If MOIC, IRR, or other financial metrics were found, analyze them in detail. If asking about "why MOIC is high/low", use the actual values found to explain.

Instructions:
1. Use the ACTUAL Excel data shown above in your analysis
2. Reference specific cells/sheets when discussing values  
3. If financial metrics are found, explain what drives them
4. Provide actionable recommendations
5. Be specific and data-driven, not generic

Respond with analysis based on the real Excel data provided.`;

                console.log('üöÄ Calling AI with comprehensive Excel data...');
                
                // Always call AI API with the real Excel data (no offline fallback)
                await callAIService(aiPrompt, loadingMessage, userInput);
                
            } catch (error) {
                console.error('‚ùå Error in processWithAI:', error);
                updateStreamingMessage(loadingMessage, `Error processing query: ${error.message}`, true);
            }
        }

        // Search all Excel sheets for financial data relevant to the query
        async function searchAllSheetsForFinancialData(query) {
            const foundData = [];
            const searchTerms = {
                moic: ['moic', 'multiple', 'cash on cash', 'return multiple'],
                irr: ['irr', 'internal rate', 'discount rate'],
                npv: ['npv', 'net present', 'present value'],
                exit: ['exit', 'terminal', 'sale price'],
                equity: ['equity', 'investment', 'invested capital'],
                revenue: ['revenue', 'sales', 'income'],
                ebitda: ['ebitda', 'earnings']
            };
            
            // Determine what we're looking for
            let targetMetrics = [];
            for (const [metric, terms] of Object.entries(searchTerms)) {
                if (terms.some(term => query.includes(term))) {
                    targetMetrics.push(metric);
                }
            }
            
            await Excel.run(async (context) => {
                try {
                    const worksheets = context.workbook.worksheets;
                    worksheets.load(['name']);
                    await context.sync();
                    
                    // Search each worksheet
                    for (const worksheet of worksheets.items) {
                        // Get a reasonable range from each sheet (first 50 rows, 20 cols)
                        const range = worksheet.getRange('A1:T50');
                        range.load(['values', 'formulas']);
                        await context.sync();
                        
                        // Search through the data
                        for (let row = 0; row < Math.min(range.values.length, 50); row++) {
                            for (let col = 0; col < Math.min(range.values[row]?.length || 0, 20); col++) {
                                const cellValue = range.values[row][col];
                                const cellFormula = range.formulas[row][col];
                                
                                if (cellValue && typeof cellValue === 'string') {
                                    const cellText = cellValue.toLowerCase();
                                    
                                    // Check if this cell contains a label we're looking for
                                    for (const [metric, terms] of Object.entries(searchTerms)) {
                                        if (terms.some(term => cellText.includes(term))) {
                                            // Found a label! Look for the value in adjacent cells
                                            const adjacentCells = [
                                                { r: row, c: col + 1 }, // Right
                                                { r: row + 1, c: col }, // Below
                                                { r: row, c: col - 1 }, // Left  
                                                { r: row - 1, c: col }  // Above
                                            ];
                                            
                                            for (const adj of adjacentCells) {
                                                if (adj.r >= 0 && adj.r < range.values.length && 
                                                    adj.c >= 0 && adj.c < range.values[adj.r]?.length) {
                                                    const adjValue = range.values[adj.r][adj.c];
                                                    const adjFormula = range.formulas[adj.r][adj.c];
                                                    
                                                    if (typeof adjValue === 'number' && adjValue !== 0) {
                                                        foundData.push({
                                                            sheet: worksheet.name,
                                                            address: `${String.fromCharCode(65 + adj.c)}${adj.r + 1}`,
                                                            label: cellValue,
                                                            value: adjValue,
                                                            formula: adjFormula,
                                                            metric: metric
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    console.log(`üîç Found ${foundData.length} financial data points:`, foundData);
                    
                } catch (searchError) {
                    console.error('‚ùå Error searching sheets:', searchError);
                }
            });
            
            return { foundData };
        }

        // Enhanced AI API call
        async function callAIService(prompt, loadingMessage, originalQuery) {
            try {
                console.log('üîÑ Calling AI service...');
                console.log('üåê Current hostname:', window.location.hostname);
                console.log('üåê Current origin:', window.location.origin);
                
                // Use the same endpoint detection as the autofill system
                const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const apiEndpoint = isLocal ? 'http://localhost:8888/.netlify/functions/chat' : '/.netlify/functions/chat';
                
                console.log('üì° API Endpoint:', apiEndpoint);
                
                const requestBody = {
                    message: prompt,
                    autoFillMode: false, // Chat mode, not autofill mode
                    batchType: 'chat', // Use a different batch type for conversational mode
                    systemPrompt: 'You are an expert Excel and M&A financial modeling assistant. Provide clear, conversational responses about the Excel data. Analyze the provided Excel data and give specific, data-driven insights in natural language.',
                    temperature: 0.7,
                    maxTokens: 3000
                };
                
                console.log('üì§ Request body:', requestBody);
                
                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('üì• Response status:', response.status);
                console.log('üì• Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API Error Response:', errorText);
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ API Response:', result);
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                let aiResponse = result.content || result.response || result.choices?.[0]?.message?.content || 'No response received';
                
                if (!aiResponse || aiResponse.trim() === '') {
                    throw new Error('Empty response from API');
                }
                
                updateStreamingMessage(loadingMessage, aiResponse, true);
                
                // Add to conversation history
                conversationHistory.push({ role: 'user', content: originalQuery });
                conversationHistory.push({ role: 'assistant', content: aiResponse });
                
                console.log('‚úÖ AI response completed successfully');
                
            } catch (error) {
                console.error('‚ùå AI API failed:', error);
                console.error('‚ùå Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                
                // Detailed error message for user
                let errorMessage = `‚ùå I'm having trouble connecting to the AI service right now.\n\n`;
                errorMessage += `Error: ${error.message}\n\n`;
                
                if (error.message.includes('fetch')) {
                    errorMessage += `This appears to be a network connectivity issue. Please:\n`;
                    errorMessage += `‚Ä¢ Check your internet connection\n`;
                    errorMessage += `‚Ä¢ Make sure the Netlify functions are deployed\n`;
                    errorMessage += `‚Ä¢ Try refreshing the page`;
                } else if (error.message.includes('API key')) {
                    errorMessage += `The OpenAI API key is not configured. Please check the Netlify environment variables.`;
                } else {
                    errorMessage += `Please try again in a moment or contact support if the issue persists.`;
                }
                
                updateStreamingMessage(loadingMessage, errorMessage, true);
            }
        }

        // STEP 3: Excel Writing Functions
        async function applyExcelChange(newValue, targetAddress) {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const range = sheet.getRange(targetAddress);
                    
                    if (newValue.startsWith('=')) {
                        range.formulas = [[newValue]];
                    } else {
                        range.values = [[newValue]];
                    }
                    
                    await context.sync();
                    console.log(`‚úÖ Applied: ${newValue} to ${targetAddress}`);
                });
            } catch (error) {
                console.error('‚ùå Error applying change:', error);
            }
        }

        async function undoExcelChange() {
            try {
                await Excel.run(async (context) => {
                    context.workbook.application.undo();
                    await context.sync();
                    console.log('‚Ü©Ô∏è Undid last change');
                });
            } catch (error) {
                console.error('‚ùå Error undoing:', error);
            }
        }

        // Initialize the comprehensive Excel+AI integration
        function initializeEnhancedExcelChat() {
            const sendButton = document.getElementById('sendMessage');
            const chatInput = document.getElementById('chatInput');
            
            if (sendButton && chatInput) {
                // Remove existing listeners
                sendButton.replaceWith(sendButton.cloneNode(true));
                const newSendButton = document.getElementById('sendMessage');
                
                // Add comprehensive handler
                newSendButton.addEventListener('click', async () => {
                    const message = chatInput.value.trim();
                    if (message) {
                        await handleUserQuery(message);
                    }
                });
                
                chatInput.addEventListener('keydown', async function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        const message = this.value.trim();
                        if (message) {
                            await handleUserQuery(message);
                        }
                    }
                });
                
                // Auto-expanding textarea
                chatInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
                
                console.log('üöÄ Enhanced Excel+AI chat system initialized');
            }
        }
        
        // Simple API test function for debugging
        async function testAPIConnection() {
            try {
                const response = await fetch('/.netlify/functions/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: 'Test connection',
                        batchType: 'financial_analysis'
                    })
                });
                
                console.log('üß™ Test API Response Status:', response.status);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('üß™ Test API Result:', result);
                } else {
                    const errorText = await response.text();
                    console.error('üß™ Test API Error:', errorText);
                }
            } catch (error) {
                console.error('üß™ Test API Connection Failed:', error);
            }
        }

        // Note: Enhanced chat is initialized in the main Office.onReady callback above
    </script>
</body>
</html>